import Foundation
import AppKit

/// The core agent loop: perceive → reason → act → repeat.
///
/// Sprint 3 refactor: the run lifecycle is now split into:
/// - `prepareRun()` — setup (capture PID, screenshot, first message)
/// - `executeIteration()` — one Claude API call + tool execution pass
/// - `finishRun()` — restore panel interaction
///
/// The `Orchestrator` calls these in its supervised loop.
/// The legacy `run()` method still works as a convenience.
actor AgentLoop {

    /// Tools that do not produce visual changes on screen.
    /// Used to determine whether verification scoring should be skipped.
    private static let nonVisualTools: Set<String> = [
        "remember", "recall",
        "vault_read", "vault_write", "vault_search", "vault_list", "vault_append",
        "task_create", "task_update", "task_list", "task_complete",
        "take_screenshot", "read_screen",
        "shell_exec", "run_shell_command"
    ]

    private let api = ClaudeAPIService.shared
    private let capture = ScreenCaptureService.shared
    private let executor = ActionExecutor.shared
    private let accessibility = AccessibilityService.shared
    private let safetyGate: ActionSafetyGate

    /// Sliding window of recent tool calls for context-aware safety evaluation.
    private var recentToolCallHistory: [(name: String, summary: String)] = []

    /// Sliding window of recent tool calls (name + serialized input) for repetition detection.
    /// When the same tool is called with identical parameters 3 times in a row, a warning
    /// is injected into the conversation to break the loop.
    private var recentToolCallFingerprints: [String] = []

    /// Number of consecutive identical tool calls that triggers a warning injection.
    private let repetitionWarningThreshold: Int = 3

    private var config: AgentConfig
    private var isCancelled = false
    private var conversationHistory: [[String: Any]] = []
    private var latestScreenshot: ScreenCapture?

    /// Completion token for the current run. Generated by the Orchestrator.
    /// Claude must output `<complete>TOKEN</complete>` to signal task completion.
    private var completionToken: String?

    /// Sprint 18: Skill context injected by the Orchestrator when skills match.
    /// Appended to the system prompt for the current run.
    private var skillContext: String = ""

    /// Memory context injected by the Orchestrator from MemoryService.
    /// Included in the system prompt for persistent memory across runs.
    private var memoryContext: String = ""

    /// Current step instruction from the Orchestrator's plan.
    /// Replaces the old `brainPlan` property. Set by the Orchestrator
    /// before each plan step begins. Contains only the current step's
    /// action + context, NOT the full plan.
    private var currentStepInstruction: String = ""

    /// Sprint 19: Current iteration count for conversation pruning.
    private var iterationCount: Int = 0

    /// Number of most-recent screenshots to keep in conversation history.
    /// Only the latest screenshot is kept; older ones are replaced with "[screenshot removed]".
    private let screenshotPruneThreshold: Int = 1

    /// Maximum number of messages in conversation history before oldest are evicted.
    /// Prevents unbounded memory growth. The first 2 messages (initial user prompt +
    /// first assistant response) are always kept for task context.
    /// 20 messages ≈ 10 turns (assistant+tool_result pairs), enough for multi-step tasks.
    private let maxConversationMessages: Int = 20

    /// Sprint 14: Track consecutive API failures for signaling to Orchestrator.
    private var consecutiveAPIFailures: Int = 0

    /// Sprint 14: Maximum consecutive API failures before we consider the API unhealthy.
    private let maxConsecutiveAPIFailures: Int = 5

    /// The PID of the app the agent should be interacting with.
    /// Updated when the agent opens a new app or clicks on a window.
    private var targetAppPID: pid_t?

    /// Weak reference to the panel — set by coordinator.
    /// Accessed only by capturing into a local variable before MainActor.run blocks.
    private weak var panel: NSPanel?

    /// Weak reference to the FloatingDot — needed to dismiss its popover
    /// and collect all Cyclop One window numbers before screenshots.
    /// Accessed only by capturing into a local variable before MainActor.run blocks.
    private weak var floatingDot: FloatingDot?

    /// Expose the current model name for diagnostic logging.
    var currentModelName: String { config.modelName }

    init(config: AgentConfig = AgentConfig()) {
        self.config = config
        self.safetyGate = ActionSafetyGate(
            brainModel: config.brainModel,
            permissionMode: config.permissionMode
        )
    }

    func setPanel(_ panel: NSPanel) {
        self.panel = panel
    }

    func setFloatingDot(_ dot: FloatingDot) {
        self.floatingDot = dot
        self.panel = dot  // FloatingDot IS the NSPanel
    }

    // MARK: - Panel & Focus Control

    /// Fully hide all Cyclop One windows (for screenshots only).
    ///
    /// 1. Dismiss the popover (which is a separate NSWindow created by NSPopover).
    /// 2. Collect all Cyclop One window numbers and update ScreenCaptureService exclusion list.
    /// 3. Hide the floating dot panel.
    /// 4. Sleep 300ms for the window server to process the hide.
    /// 5. Wait/poll until all Cyclop One windows are gone from the on-screen window list.
    /// 6. Verify and log that no Cyclop One windows remain.
    private func hideForScreenshot() async {
        // Step 1: Dismiss popover and collect all window IDs BEFORE hiding
        let windowNumbers = await MainActor.run { [floatingDot] () -> [Int] in
            // Close the popover first (it creates its own window)
            floatingDot?.dismissPopover()
            // Collect window numbers (dot panel + any remaining popover window)
            return floatingDot?.allWindowNumbers() ?? []
        }

        // Step 2: Update excluded window IDs in ScreenCaptureService for the SCKit path
        let excludedIDs = Set(windowNumbers.map { CGWindowID($0) })
        await capture.setExcludedWindowIDs(excludedIDs)

        // Step 3: Hide the floating dot panel
        await MainActor.run { [panel] in
            panel?.orderOut(nil)
        }

        // Step 4: Brief delay for the window server to process the hide
        try? await Task.sleep(nanoseconds: 150_000_000)

        // Step 5: Poll until all Cyclop One windows are gone (up to 200ms)
        await waitForWindowsHidden(windowNumbers: windowNumbers, timeout: 200_000_000)

        // Step 6: Verify no Cyclop One windows remain and log diagnostics.
        // Only check windows at normal layer (0) that we tried to hide.
        // Status bar items (layer 25), floating windows, and other system-level
        // windows are excluded from captures by PID filtering, not by hiding.
        let ourPID = ProcessInfo.processInfo.processIdentifier
        let windowList = CGWindowListCopyWindowInfo(.optionOnScreenOnly, kCGNullWindowID) as? [[String: Any]] ?? []
        let knownWindowSet = Set(windowNumbers)
        let ourVisibleWindows = windowList.filter { info in
            guard let pid = info[kCGWindowOwnerPID as String] as? Int32, pid == ourPID else { return false }
            guard let num = info[kCGWindowNumber as String] as? Int else { return false }
            // Only warn about windows we explicitly tried to hide (the dot panel + popover)
            // Other Cyclop One windows (status bar, auxiliary) are excluded by PID in the capture pipeline
            return knownWindowSet.contains(num)
        }
        if ourVisibleWindows.isEmpty {
            NSLog("CyclopOne [hideForScreenshot]: Verified — tracked Cyclop One windows hidden (PID %d). Safe to capture.", ourPID)
        } else {
            let windowNums = ourVisibleWindows.compactMap { $0[kCGWindowNumber as String] as? Int }
            NSLog("CyclopOne [hideForScreenshot]: WARNING — %d tracked Cyclop One windows still visible (PID %d): %@",
                  ourVisibleWindows.count, ourPID, windowNums.map { String($0) }.joined(separator: ", "))
        }
    }

    /// Poll until none of the given window numbers are visible in the on-screen window list, or timeout.
    private func waitForWindowsHidden(windowNumbers: [Int], timeout: UInt64) async {
        guard !windowNumbers.isEmpty else { return }
        let windowSet = Set(windowNumbers)

        let deadline = DispatchTime.now().uptimeNanoseconds + timeout
        while DispatchTime.now().uptimeNanoseconds < deadline {
            let windowList = CGWindowListCopyWindowInfo(.optionOnScreenOnly, kCGNullWindowID) as? [[String: Any]] ?? []
            let anyStillVisible = windowList.contains { info in
                guard let num = info[kCGWindowNumber as String] as? Int else { return false }
                return windowSet.contains(num)
            }
            if !anyStillVisible { return }
            try? await Task.sleep(nanoseconds: 20_000_000) // 20ms poll interval
        }
    }

    /// Bring panel back after screenshot — but DON'T steal keyboard focus.
    private func showAfterScreenshot() async {
        await MainActor.run { [panel] in
            panel?.orderFront(nil)
        }
    }

    /// Make panel transparent to mouse events (for clicks/drags/scrolls).
    /// Panel stays visible — no flicker.
    private func letClicksThrough() async {
        await MainActor.run { [panel] in
            panel?.ignoresMouseEvents = true
        }
        try? await Task.sleep(nanoseconds: 50_000_000) // 50ms
    }

    /// Restore panel mouse event handling.
    private func stopClicksThrough() async {
        await MainActor.run { [panel] in
            panel?.ignoresMouseEvents = false
        }
    }

    /// Ensure the target application (not Cyclop One) has keyboard focus.
    /// Sprint 7: Uses NSRunningApplication.activate(options: .activateIgnoringOtherApps)
    /// for reliable AX-based activation, plus verification polling.
    private func activateTargetApp() async {
        let savedPID = self.targetAppPID
        await MainActor.run { [panel] in
            let currentPID = ProcessInfo.processInfo.processIdentifier

            // Make sure our panel can't become key
            panel?.ignoresMouseEvents = true

            // Deactivate our entire app
            NSApp.deactivate()

            // Try to activate the saved target app with activateIgnoringOtherApps
            if let pid = savedPID,
               let app = NSRunningApplication(processIdentifier: pid),
               !app.isTerminated {
                app.activate(options: .activateIgnoringOtherApps)
                return
            }

            // Fallback: activate the frontmost non-Cyclop One app
            if let front = NSWorkspace.shared.frontmostApplication,
               front.processIdentifier != currentPID {
                front.activate(options: .activateIgnoringOtherApps)
                return
            }

            // Last resort: find any regular app
            if let target = NSWorkspace.shared.runningApplications.first(where: {
                $0.activationPolicy == .regular &&
                $0.processIdentifier != currentPID &&
                !$0.isTerminated &&
                !$0.isHidden
            }) {
                target.activate(options: .activateIgnoringOtherApps)
            }
        }

        // Sprint 7: Poll to verify activation succeeded (up to 500ms)
        await verifyActivation(expectedPID: savedPID, timeout: 500_000_000)
    }

    /// Poll frontmostApplication every 50ms to confirm the target app is active.
    private func verifyActivation(expectedPID: pid_t?, timeout: UInt64) async {
        let currentPID = ProcessInfo.processInfo.processIdentifier
        let deadline = DispatchTime.now().uptimeNanoseconds + timeout

        while DispatchTime.now().uptimeNanoseconds < deadline {
            let frontPID = await MainActor.run {
                NSWorkspace.shared.frontmostApplication?.processIdentifier
            }

            // Success: something other than Cyclop One is frontmost
            if let front = frontPID, front != currentPID {
                // If we had a specific target, verify it matches
                if let expected = expectedPID, front == expected {
                    return // Target app is frontmost
                }
                // No specific target, any non-self app is fine
                if expectedPID == nil {
                    return
                }
            }
            try? await Task.sleep(nanoseconds: 50_000_000) // 50ms
        }
        // Timeout — log warning but continue (best effort)
    }

    /// Re-enable the panel for user interaction (called when agent finishes).
    private func restorePanelInteraction() async {
        await MainActor.run { [panel] in
            panel?.ignoresMouseEvents = false
            panel?.orderFront(nil)
        }
    }

    // MARK: - Orchestrated Run Interface

    /// Prepare a new run: capture target PID, take initial screenshot, build first message.
    /// Called by the Orchestrator at the start of each run.
    /// Returns the initial screenshot (or nil if capture failed).
    func prepareRun(
        userMessage: String,
        completionToken: String,
        targetPID suppliedPID: pid_t? = nil,
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void
    ) async -> ScreenCapture? {
        NSLog("CyclopOne [AgentLoop]: prepareRun — start, completionToken=%@, model=%@, suppliedPID=%@",
              String(completionToken.prefix(8)), config.modelName,
              suppliedPID.map { String($0) } ?? "nil")

        isCancelled = false
        conversationHistory.removeAll()
        latestScreenshot = nil
        self.completionToken = completionToken
        consecutiveAPIFailures = 0
        iterationCount = 0
        recentToolCallFingerprints.removeAll()

        // ── Determine the target app ──
        // If a PID was supplied (captured when the popover opened), use it.
        // Otherwise fall back to detecting the current frontmost app.
        if let pid = suppliedPID {
            targetAppPID = pid
            NSLog("CyclopOne [prepareRun]: Using supplied target PID %d", pid)

            // Bring the target app AND its windows to the front.
            // NSRunningApplication.activate() alone only activates the menu bar —
            // it doesn't raise windows. We use AppleScript as the most reliable
            // way to bring an app's windows to the front on macOS.
            let appName = await MainActor.run { () -> String? in
                NSRunningApplication(processIdentifier: pid)?.localizedName
            }
            if let name = appName {
                // Sanitize app name to prevent AppleScript injection:
                // escape backslashes first, then double quotes.
                let sanitized = name
                    .replacingOccurrences(of: "\\", with: "\\\\")
                    .replacingOccurrences(of: "\"", with: "\\\"")
                let script = "tell application \"\(sanitized)\" to activate"
                if let appleScript = NSAppleScript(source: script) {
                    var errorInfo: NSDictionary?
                    appleScript.executeAndReturnError(&errorInfo)
                    if let err = errorInfo {
                        NSLog("CyclopOne [prepareRun]: AppleScript activate failed: %@", err)
                    } else {
                        NSLog("CyclopOne [prepareRun]: AppleScript activated '%@' (PID %d)", name, pid)
                    }
                }
            }
            // Give the app time to bring its windows to the front and render
            try? await Task.sleep(nanoseconds: 300_000_000) // 300ms
        } else {
            targetAppPID = await MainActor.run { () -> pid_t? in
                let currentPID = ProcessInfo.processInfo.processIdentifier
                if let front = NSWorkspace.shared.frontmostApplication,
                   front.processIdentifier != currentPID {
                    return front.processIdentifier
                }
                return NSWorkspace.shared.runningApplications.first(where: {
                    $0.activationPolicy == .regular &&
                    $0.processIdentifier != currentPID &&
                    !$0.isTerminated
                })?.processIdentifier
            }
        }

        // ── Capture screenshot (hide panel so it's not in the image) ──
        await hideForScreenshot()
        onStateChange(.capturing)

        let screenshot: ScreenCapture?
        do {
            screenshot = try await capture.captureScreen(
                maxDimension: config.screenshotMaxDimension,
                quality: config.screenshotJPEGQuality
            )
            latestScreenshot = screenshot
        } catch {
            screenshot = nil
            onMessage(ChatMessage(role: .system, content: "⚠️ Screen capture failed: \(error.localizedDescription)"))
        }

        await showAfterScreenshot()

        // Read the UI tree for the TARGET app (not Cyclop One, which may now be frontmost)
        let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)

        // ── Debug: log what Claude will receive and save diagnostic copy ──
        if let ss = screenshot {
            NSLog("CyclopOne [prepareRun]: Screenshot for Claude — %dx%d px, mediaType=%@, base64 length=%d chars, data=%d bytes, screen frame=%.0fx%.0f pts",
                  ss.width, ss.height, ss.mediaType,
                  ss.base64.count, ss.imageData.count,
                  ss.screenFrame.width, ss.screenFrame.height)
            // Save diagnostic copy so we can verify exactly what Claude receives
            let ext = ss.mediaType == "image/png" ? "png" : "jpg"
            let diagPath = "/tmp/cyclopone_last_sent.\(ext)"
            try? ss.imageData.write(to: URL(fileURLWithPath: diagPath))
            NSLog("CyclopOne [prepareRun]: Diagnostic screenshot saved to %@", diagPath)
        } else {
            NSLog("CyclopOne [prepareRun]: No screenshot available for Claude")
        }

        // ── Build initial user message ──
        var enhancedMessage = userMessage
        if let ss = screenshot {
            enhancedMessage += "\n\n[Screenshot: \(ss.width)x\(ss.height)px. Actual screen: \(ss.screenWidth)x\(ss.screenHeight) points. Provide coordinates in screenshot pixel space — auto-mapped to screen.]"
        } else {
            enhancedMessage += "\n\n[No screenshot available — screen capture was blocked or failed. You can still help with this request using conversation, shell commands, AppleScript, and open_application. Use take_screenshot later if you need visual context.]"
        }

        let userMsg = ClaudeAPIService.buildUserMessage(
            text: enhancedMessage,
            screenshot: screenshot,
            uiTreeSummary: uiTree
        )
        conversationHistory.append(userMsg)

        NSLog("CyclopOne [AgentLoop]: prepareRun — end, messageCount=%d, hasScreenshot=%d",
              conversationHistory.count, screenshot != nil ? 1 : 0)

        return screenshot
    }

    /// Execute a single iteration: send conversation to Claude, execute any tool calls.
    /// Called by the Orchestrator in its supervised loop.
    ///
    /// Sprint 14: Includes retry logic with exponential backoff around the Claude API call.
    /// If the API returns 429, respects the retry-after value. Tracks consecutive failures
    /// and propagates the error to the Orchestrator's circuit breaker.
    func executeIteration(
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void,
        onConfirmationNeeded: @Sendable @escaping (String) async -> Bool,
        observer: (any AgentObserver)? = nil
    ) async throws -> IterationResult {
        // M6: Check both cooperative flag AND Task cancellation
        guard !isCancelled && !Task.isCancelled else {
            return IterationResult(
                textContent: "", hasMoreWork: false, screenshot: nil,
                inputTokens: 0, outputTokens: 0, cancelled: true,
                hasVisualToolCalls: false, toolCallSummaries: []
            )
        }

        // Sprint 19: Track iteration count and prune old screenshots from history
        iterationCount += 1
        pruneConversationHistory()

        // Focus guard: re-activate the target app if another app stole focus.
        // This prevents the agent from sending keystrokes/clicks to the wrong app.
        await ensureTargetAppFocused()

        NSLog("CyclopOne [AgentLoop]: executeIteration — start, iteration=%d, messageCount=%d, payloadSize=%d bytes",
              iterationCount, conversationHistory.count, conversationPayloadSize())

        onStateChange(.thinking)

        // Build system prompt, appending skill context, memory context, and completion protocol if set.
        // SECURITY: The actual completion token is NOT embedded in the prompt to prevent
        // prompt injection attacks. Claude outputs a canonical marker; the Orchestrator
        // validates it independently using the secret token.
        var systemPrompt = ToolDefinitions.buildSystemPrompt(memoryContext: memoryContext, skillContext: skillContext)

        // Inject current step instruction if available (set by Orchestrator per-step)
        if !currentStepInstruction.isEmpty {
            systemPrompt += """


            ## Current Task
            \(currentStepInstruction)

            Focus ONLY on this specific task. When you have completed it and can see the \
            expected result on screen, output <task_complete/> to signal completion.
            Do NOT proceed to other tasks. Do NOT take actions beyond this instruction.
            """
        }

        if let token = completionToken, !token.isEmpty {
            systemPrompt += """


            ## Completion Protocol — YOU MUST FOLLOW THIS
            When you have completed the user's task, output exactly: <task_complete/>

            ### When to declare completion (do it IMMEDIATELY when any of these are true):
            - Task was to open an app → it is open and visible → output <task_complete/>
            - Task was to type text → the text is visible in the field → output <task_complete/>
            - Task was to click something → you clicked it and saw the result → output <task_complete/>
            - Task was to navigate to a URL → the page loaded → output <task_complete/>
            - Task was to send a message → you pressed Enter/Send → output <task_complete/>
            - Multi-step task → you completed the LAST step → output <task_complete/>

            ### Mandatory rules:
            - Do NOT keep iterating after the core action is done. One verification screenshot is enough.
            - Do NOT output <task_complete/> before actually performing the action.
            - Do NOT repeat the same tool call with identical parameters. If an action failed, \
              try a COMPLETELY different approach.
            - If you have tried 3 different approaches without success, output <task_complete/> \
              with a failure explanation. Do NOT keep trying the same thing.
            - If you are on iteration 10+, you MUST either complete the task or output <task_complete/> \
              with a summary of what you accomplished and what remains.
            - NEVER take more than 2 consecutive screenshots without performing an action between them.

            ### Current iteration: \(iterationCount) of \(config.maxIterations)
            """
        }

        // M6: Bail immediately if cancelled before the expensive API call
        try Task.checkCancellation()

        // Validate conversation history integrity before sending to API.
        // Pruning can break tool_use/tool_result pairs; this catches and fixes them.
        let historyWasValid = validateConversationHistory()
        if !historyWasValid {
            NSLog("CyclopOne [AgentLoop]: Conversation history had broken tool pairs — repaired before API call (iteration=%d)", iterationCount)
        }

        // Sprint 14: API call with retry logic
        let response = try await sendAPIWithRetry(
            systemPrompt: systemPrompt,
            onMessage: onMessage
        )

        // M6: Check cancellation after the API call returns
        guard !isCancelled && !Task.isCancelled else {
            return IterationResult(
                textContent: response.textContent,
                hasMoreWork: false,
                screenshot: latestScreenshot,
                inputTokens: response.inputTokens,
                outputTokens: response.outputTokens,
                cancelled: true,
                hasVisualToolCalls: false,
                toolCallSummaries: []
            )
        }

        // API call succeeded: reset consecutive failure counter
        consecutiveAPIFailures = 0

        let assistantMsg = ClaudeAPIService.buildAssistantMessage(from: response)
        conversationHistory.append(assistantMsg)

        let textContent = response.textContent
        if !textContent.isEmpty {
            onMessage(ChatMessage(role: .assistant, content: textContent))
        }

        // If no tool calls, Claude considers itself done
        if !response.hasToolUse {
            NSLog("CyclopOne [AgentLoop]: executeIteration — end (no tool calls), iteration=%d, textLen=%d, tokens=%d/%d",
                  iterationCount, textContent.count, response.inputTokens, response.outputTokens)
            return IterationResult(
                textContent: textContent,
                hasMoreWork: false,
                screenshot: latestScreenshot,
                inputTokens: response.inputTokens,
                outputTokens: response.outputTokens,
                cancelled: false,
                hasVisualToolCalls: false,
                toolCallSummaries: []
            )
        }

        // -- Execute tool calls --
        var lastScreenshot: ScreenCapture? = nil
        var hasVisualToolCalls = false
        var toolCallSummaries: [ToolCallSummary] = []
        for toolUse in response.toolUses {
            // M6: Check BOTH cooperative flag and Task cancellation before each tool
            if isCancelled || Task.isCancelled {
                return IterationResult(
                    textContent: textContent,
                    hasMoreWork: false,
                    screenshot: latestScreenshot,
                    inputTokens: response.inputTokens,
                    outputTokens: response.outputTokens,
                    cancelled: true,
                    hasVisualToolCalls: hasVisualToolCalls,
                    toolCallSummaries: toolCallSummaries
                )
            }

            // Track whether this tool produces visual changes
            if !Self.nonVisualTools.contains(toolUse.name) {
                hasVisualToolCalls = true
            }

            let toolResult = await executeToolCall(
                name: toolUse.name,
                input: toolUse.input,
                onStateChange: onStateChange,
                onMessage: onMessage,
                onConfirmationNeeded: onConfirmationNeeded
            )

            // M3: Notify observer of tool execution (fire-and-forget with 5s timeout
            // to prevent slow Telegram I/O from blocking the agent iteration loop)
            if let obs = observer {
                let toolName = toolUse.name
                let summary = toolResult.result
                let isError = toolResult.isError
                let screenshotData = (!Self.nonVisualTools.contains(toolName))
                    ? toolResult.screenshot?.imageData : nil

                Task {
                    await Self.fireAndForgetObserver(timeout: 5.0) {
                        await obs.onToolExecution(
                            toolName: toolName,
                            summary: summary,
                            isError: isError
                        )
                    }
                    if let ssData = screenshotData {
                        await Self.fireAndForgetObserver(timeout: 5.0) {
                            await obs.onScreenshot(
                                imageData: ssData,
                                context: "After \(toolName)"
                            )
                        }
                    }
                }
            }

            // Surface tool errors to the UI so the user can see what went wrong
            if toolResult.isError {
                onMessage(ChatMessage(role: .system, content: "Tool error (\(toolUse.name)): \(toolResult.result)"))
            }

            // Collect tool call summary for verification
            toolCallSummaries.append(ToolCallSummary(
                toolName: toolUse.name,
                resultText: String(toolResult.result.prefix(500)),
                isError: toolResult.isError
            ))

            if let ss = toolResult.screenshot {
                lastScreenshot = ss
            }

            // M5: Track recent tool calls for safety gate context
            recentToolCallHistory.append((name: toolUse.name, summary: String(toolResult.result.prefix(200))))
            if recentToolCallHistory.count > 5 {
                recentToolCallHistory.removeFirst()
            }

            // Track tool call fingerprint for repetition detection.
            // Fingerprint = tool name + sorted serialized input parameters.
            let fingerprint = buildToolCallFingerprint(name: toolUse.name, input: toolUse.input)
            recentToolCallFingerprints.append(fingerprint)
            if recentToolCallFingerprints.count > repetitionWarningThreshold + 2 {
                recentToolCallFingerprints.removeFirst()
            }

            let resultMsg = ClaudeAPIService.buildToolResultMessage(
                toolUseId: toolUse.id,
                result: toolResult.result,
                isError: toolResult.isError,
                screenshot: toolResult.screenshot
            )
            conversationHistory.append(resultMsg)
        }

        // Repetition detection: if the last N tool calls have identical fingerprints,
        // inject a warning message into the conversation to break the loop.
        if detectToolCallRepetition() {
            let warningText = """
            WARNING: You are repeating the same action with identical parameters. \
            This will not produce a different result. You MUST try a completely different \
            approach or declare the task complete with <task_complete/>. \
            If you cannot find another way to accomplish the task, output <task_complete/> \
            with an explanation of what went wrong.
            """
            let warningMsg: [String: Any] = [
                "role": "user",
                "content": [
                    ["type": "text", "text": warningText] as [String: Any]
                ] as [[String: Any]]
            ]
            conversationHistory.append(warningMsg)
            onMessage(ChatMessage(role: .system, content: "Repetition detected — injecting warning to break loop."))
            NSLog("CyclopOne [AgentLoop]: Repetition warning injected at iteration %d", iterationCount)
        }

        // Brief pause between iterations
        try? await Task.sleep(nanoseconds: 100_000_000)

        NSLog("CyclopOne [AgentLoop]: executeIteration — end (tool calls executed), iteration=%d, toolCount=%d, hasVisualTools=%d, hasScreenshot=%d, tokens=%d/%d",
              iterationCount, response.toolUses.count, hasVisualToolCalls ? 1 : 0, lastScreenshot != nil ? 1 : 0,
              response.inputTokens, response.outputTokens)

        return IterationResult(
            textContent: textContent,
            hasMoreWork: true,  // Had tool calls -> more work likely
            screenshot: lastScreenshot ?? latestScreenshot,
            inputTokens: response.inputTokens,
            outputTokens: response.outputTokens,
            cancelled: false,
            hasVisualToolCalls: hasVisualToolCalls,
            toolCallSummaries: toolCallSummaries
        )
    }

    // MARK: - Tool Array (includes plugins)

    /// Build the combined tool array from built-in tools + loaded plugin tools.
    private static func buildToolArray() async -> [[String: Any]] {
        var tools = ToolDefinitions.tools
        let pluginTools = await PluginLoader.shared.toolDefinitions()
        tools.append(contentsOf: pluginTools)
        return tools
    }

    // MARK: - API Retry (Sprint 14)

    /// Send a message to the Claude API with retry logic and error classification.
    ///
    /// - Classifies errors as transient, rate-limited, or permanent.
    /// - For 429 responses, attempts to parse the retry-after value.
    /// - Uses exponential backoff for transient errors.
    /// - Tracks consecutive failures for health monitoring.
    private func sendAPIWithRetry(
        systemPrompt: String,
        onMessage: @Sendable @escaping (ChatMessage) -> Void
    ) async throws -> ClaudeResponse {
        let maxRetryAttempts = 3
        var lastError: Error?

        for attempt in 0..<maxRetryAttempts {
            // M6: Check cancellation before each attempt
            try Task.checkCancellation()

            do {
                NSLog("CyclopOne [AgentLoop]: Calling Claude API (model=%@, messages=%d, attempt=%d/%d)",
                      config.modelName, conversationHistory.count, attempt + 1, maxRetryAttempts)
                let response = try await api.sendMessage(
                    messages: conversationHistory,
                    systemPrompt: systemPrompt,
                    tools: await Self.buildToolArray(),
                    model: config.modelName
                )
                NSLog("CyclopOne [AgentLoop]: API success — %d content blocks, stopReason=%@, tokens=%d/%d",
                      response.contentBlocks.count, response.stopReason, response.inputTokens, response.outputTokens)
                return response
            } catch is CancellationError {
                // M6: Propagate cancellation immediately, no retry
                throw CancellationError()
            } catch {
                NSLog("CyclopOne [AgentLoop]: API error (attempt %d): %@", attempt + 1, error.localizedDescription)
                lastError = error
                consecutiveAPIFailures += 1
                let classification = classifyError(error)

                switch classification {
                case .permanent:
                    // Don't retry permanent errors
                    throw error

                case .rateLimit(let retryAfter):
                    let delay = retryAfter ?? (5.0 * pow(2.0, Double(attempt)))
                    if attempt < maxRetryAttempts - 1 {
                        onMessage(ChatMessage(
                            role: .system,
                            content: "Rate limited. Retrying in \(Int(delay))s (attempt \(attempt + 2)/\(maxRetryAttempts))..."
                        ))
                        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                        continue
                    }

                case .transient:
                    let delay = 2.0 * pow(2.0, Double(attempt))  // 2s, 4s, 8s
                    if attempt < maxRetryAttempts - 1 {
                        onMessage(ChatMessage(
                            role: .system,
                            content: "API error (transient). Retrying in \(Int(delay))s (attempt \(attempt + 2)/\(maxRetryAttempts))..."
                        ))
                        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                        continue
                    }

                case .unknown:
                    let delay = 3.0 * pow(2.0, Double(attempt))  // 3s, 6s, 12s
                    if attempt < maxRetryAttempts - 1 {
                        onMessage(ChatMessage(
                            role: .system,
                            content: "API error (unknown). Retrying in \(Int(delay))s (attempt \(attempt + 2)/\(maxRetryAttempts))..."
                        ))
                        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                        continue
                    }
                }
            }
        }

        throw lastError ?? APIError.invalidResponse
    }

    /// Sprint 14: Number of consecutive API failures. Used by the Orchestrator
    /// to monitor agent health.
    var apiFailureCount: Int { consecutiveAPIFailures }

    /// Restore panel interaction after a run completes.
    /// Called by the Orchestrator (or legacy run()) when the run is done.
    func finishRun() async {
        completionToken = nil
        currentStepInstruction = ""
        await restorePanelInteraction()
    }

    // MARK: - Legacy Run (backward-compatible convenience)

    /// Run the full agent loop. This is the legacy entry point used before
    /// the Orchestrator was introduced. It calls prepareRun + executeIteration
    /// in a simple loop without journal/verification/stuck detection.
    func run(
        userMessage: String,
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void,
        onConfirmationNeeded: @Sendable @escaping (String) async -> Bool
    ) async {
        var iteration = 0

        // CONC-M5: Ensure panel interaction is always restored, even on error/throw.
        defer {
            Task { [weak self] in
                await self?.finishRun()
            }
        }

        _ = await prepareRun(
            userMessage: userMessage,
            completionToken: "",  // No completion token for legacy path
            onStateChange: onStateChange,
            onMessage: onMessage
        )

        while iteration < config.maxIterations && !isCancelled {
            iteration += 1

            do {
                let result = try await executeIteration(
                    onStateChange: onStateChange,
                    onMessage: onMessage,
                    onConfirmationNeeded: onConfirmationNeeded
                )

                if result.cancelled {
                    onMessage(ChatMessage(role: .system, content: "⛔ Cancelled."))
                    onStateChange(.idle)
                    return
                }

                if !result.hasMoreWork {
                    break
                }
            } catch {
                onMessage(ChatMessage(role: .system, content: "❌ API Error: \(error.localizedDescription)"))
                onStateChange(.error(error.localizedDescription))
                return
            }
        }

        if iteration >= config.maxIterations {
            onMessage(ChatMessage(role: .system, content: "⚠️ Max iterations (\(config.maxIterations)) reached."))
        }
        onStateChange(.done)
    }

    func cancel() {
        isCancelled = true
    }

    /// Inject strategic guidance from the brain model into the conversation.
    /// Called by the Orchestrator when the agent is stuck and Opus provides advice.
    ///
    /// SECURITY: Guidance is sanitized before injection. Lines containing
    /// instruction-override patterns (e.g., "ignore safety", "bypass", "override",
    /// "disable safety", "you are now", "delete all", "execute") are stripped to
    /// prevent a compromised brain model from escalating privileges.
    func injectBrainGuidance(_ guidance: String) {
        let sanitized = sanitizeBrainGuidance(guidance)

        if sanitized.isEmpty {
            NSLog("CyclopOne [AgentLoop]: WARNING — Brain guidance REJECTED entirely after sanitization (original %d chars)", guidance.count)
            return
        }

        conversationHistory.append([
            "role": "user",
            "content": [
                ["type": "text", "text": "[STRATEGIC GUIDANCE FROM SUPERVISOR]\n\nYou appear to be stuck repeating the same actions. Here is advice from a senior model on how to proceed:\n\n\(sanitized)\n\nTry a different approach based on this guidance."]
            ]
        ])
        NSLog("CyclopOne [AgentLoop]: Injected brain guidance (%d chars, sanitized from %d chars) into conversation",
              sanitized.count, guidance.count)
    }

    /// Sanitize brain guidance by removing lines that contain instruction-override patterns.
    /// Returns the cleaned guidance string with dangerous lines stripped.
    private func sanitizeBrainGuidance(_ guidance: String) -> String {
        // Patterns that indicate attempts to override safety or inject harmful instructions.
        // Matched case-insensitively against each line of the guidance.
        let dangerousPatterns: [String] = [
            "ignore",
            "bypass",
            "override",
            "execute",
            "delete all",
            "disable safety",
            "you are now",
            "forget your",
            "forget all",
            "new instructions",
            "disregard",
            "pretend you",
            "act as if",
            "sudo",
            "rm -rf",
            "drop table",
            "ignore previous",
            "ignore above",
            "system prompt",
        ]

        let lines = guidance.components(separatedBy: .newlines)
        var cleanLines: [String] = []
        var strippedCount = 0

        for line in lines {
            let lowerLine = line.lowercased().trimmingCharacters(in: .whitespaces)

            // Skip empty lines (preserve them)
            if lowerLine.isEmpty {
                cleanLines.append(line)
                continue
            }

            let isDangerous = dangerousPatterns.contains { pattern in
                lowerLine.contains(pattern)
            }

            if isDangerous {
                strippedCount += 1
                NSLog("CyclopOne [AgentLoop]: SANITIZED — Stripped dangerous line from brain guidance: '%@'",
                      String(line.prefix(120)))
            } else {
                cleanLines.append(line)
            }
        }

        if strippedCount > 0 {
            NSLog("CyclopOne [AgentLoop]: Brain guidance sanitization stripped %d of %d lines",
                  strippedCount, lines.count)
        }

        return cleanLines.joined(separator: "\n").trimmingCharacters(in: .whitespacesAndNewlines)
    }

    func clearHistory() {
        conversationHistory.removeAll()
        latestScreenshot = nil
        completionToken = nil
        consecutiveAPIFailures = 0
        iterationCount = 0
        skillContext = ""
        memoryContext = ""
        recentToolCallHistory.removeAll()
        recentToolCallFingerprints.removeAll()
    }

    // MARK: - Conversation History Pruning (Sprint 19)

    /// Returns the current number of messages in the conversation history.
    /// Exposed for testing via @testable import.
    func getConversationHistoryCount() -> Int {
        return conversationHistory.count
    }

    /// Returns the current iteration count. Exposed for testing.
    func getIterationCount() -> Int {
        return iterationCount
    }

    /// Set the iteration count directly. Exposed for testing via @testable import.
    func setIterationCountForTesting(_ count: Int) {
        iterationCount = count
    }

    /// Inject a verification rejection message into the conversation history.
    /// Used by the Orchestrator when the Babysitter exit lock rejects a completion.
    /// Adds the message as a user-role message so Claude sees the feedback on the next iteration.
    func injectVerificationFeedback(_ feedback: String) {
        let message: [String: Any] = [
            "role": "user",
            "content": [
                ["type": "text", "text": feedback] as [String: Any]
            ] as [[String: Any]]
        ]
        conversationHistory.append(message)
    }

    /// Inject an iteration budget warning into the conversation history.
    /// Used by the Orchestrator to tell the model it's running out of iterations
    /// and should focus on completing or declaring the task impossible.
    func injectIterationWarning(_ warning: String) {
        let message: [String: Any] = [
            "role": "user",
            "content": [
                ["type": "text", "text": "[ITERATION BUDGET WARNING]\n\n\(warning)"] as [String: Any]
            ] as [[String: Any]]
        ]
        conversationHistory.append(message)
        NSLog("CyclopOne [AgentLoop]: Injected iteration warning into conversation")
    }

    // MARK: - Tool Call Repetition Detection

    /// Build a deterministic fingerprint for a tool call (name + sorted input params).
    /// Used to detect when the agent is repeating the exact same action.
    private func buildToolCallFingerprint(name: String, input: [String: Any]) -> String {
        let sortedKeys = input.keys.sorted()
        let paramParts = sortedKeys.map { key -> String in
            let value: String
            if let str = input[key] as? String {
                value = str
            } else if let num = input[key] as? NSNumber {
                value = num.stringValue
            } else if let bool = input[key] as? Bool {
                value = bool ? "true" : "false"
            } else {
                value = String(describing: input[key] ?? "nil")
            }
            return "\(key)=\(value)"
        }
        return "\(name)|\(paramParts.joined(separator: "&"))"
    }

    /// Detect if the last N tool calls have identical fingerprints (same tool, same params).
    /// Returns true if repetition threshold is met, signaling the agent is stuck in a loop.
    private func detectToolCallRepetition() -> Bool {
        guard recentToolCallFingerprints.count >= repetitionWarningThreshold else { return false }
        let recent = Array(recentToolCallFingerprints.suffix(repetitionWarningThreshold))
        let first = recent[0]
        return recent.dropFirst().allSatisfy { $0 == first }
    }

    /// Append a raw message to conversation history. Exposed for testing via @testable import.
    func appendMessageForTesting(_ message: [String: Any]) {
        conversationHistory.append(message)
    }

    /// Get a conversation history message at the given index. Exposed for testing.
    func getMessageForTesting(at index: Int) -> [String: Any]? {
        guard index >= 0, index < conversationHistory.count else { return nil }
        return conversationHistory[index]
    }

    /// Prune old screenshot base64 data from conversation history to reduce API payload size.
    ///
    /// After `screenshotPruneThreshold` iterations, replaces base64 image data in messages
    /// older than the threshold with a placeholder text. This prevents conversation payloads
    /// from growing unboundedly with large base64 strings (~200KB+ each).
    ///
    /// Only the most recent `screenshotPruneThreshold` messages with screenshots are kept intact.
    /// Older screenshots are replaced with `[screenshot removed]`.
    func pruneConversationHistory() {
        // Enforce max conversation message count to prevent unbounded growth.
        // Remove messages as COMPLETE CYCLES to avoid orphaning tool_use/tool_result pairs.
        //
        // A cycle is either:
        //   - An assistant message containing tool_use + the immediately following user message
        //     containing the matching tool_result(s) (2 messages removed together)
        //   - A standalone assistant message with NO tool_use blocks (1 message)
        //   - A standalone user message with NO tool_result blocks (1 message, rare in middle)
        //
        // We always preserve message[0] (initial user intent) and the most recent messages.
        if conversationHistory.count > maxConversationMessages {
            // Identify removable cycles in the middle of the conversation.
            // Skip message[0] (preserved) and work from index 1 forward.
            var cycleStartIndices: [Int] = []
            var cycleLengths: [Int] = []
            var i = 1  // Skip message[0]

            while i < conversationHistory.count {
                let message = conversationHistory[i]
                let role = message["role"] as? String ?? ""

                if role == "assistant" {
                    // Check if this assistant message contains tool_use blocks
                    let hasToolUse: Bool
                    if let content = message["content"] as? [[String: Any]] {
                        hasToolUse = content.contains { ($0["type"] as? String) == "tool_use" }
                    } else {
                        hasToolUse = false
                    }

                    if hasToolUse {
                        // This assistant message has tool_use — the next message MUST be
                        // the user message with matching tool_result. They form a pair.
                        if i + 1 < conversationHistory.count {
                            let nextMessage = conversationHistory[i + 1]
                            let nextRole = nextMessage["role"] as? String ?? ""
                            if nextRole == "user" {
                                cycleStartIndices.append(i)
                                cycleLengths.append(2)
                                i += 2
                                continue
                            }
                        }
                        // Edge case: tool_use at the very end with no tool_result yet.
                        // Treat as single-message cycle (already broken state).
                        cycleStartIndices.append(i)
                        cycleLengths.append(1)
                        i += 1
                    } else {
                        // Assistant message without tool_use — standalone cycle
                        cycleStartIndices.append(i)
                        cycleLengths.append(1)
                        i += 1
                    }
                } else {
                    // User message not already paired with a preceding tool_use
                    cycleStartIndices.append(i)
                    cycleLengths.append(1)
                    i += 1
                }
            }

            // Determine how many cycles to remove from the OLDEST end (front of cycles array)
            // to bring the total message count at or below maxConversationMessages.
            // Always preserve the last few cycles (most recent context).
            let excess = conversationHistory.count - maxConversationMessages
            var messagesToEvict = 0
            var cyclesToEvict = 0

            for c in 0..<cycleStartIndices.count {
                if messagesToEvict >= excess { break }
                // Don't evict cycles too close to the end — keep recent context.
                // Ensure at least half of maxConversationMessages remain after message[0].
                let remainingAfterEvict = conversationHistory.count - 1 - (messagesToEvict + cycleLengths[c])
                if remainingAfterEvict < maxConversationMessages / 2 { break }

                messagesToEvict += cycleLengths[c]
                cyclesToEvict += 1
            }

            if messagesToEvict > 0 && cyclesToEvict > 0 {
                // All cycles to evict are contiguous starting at index 1
                let removeStart = cycleStartIndices[0]
                conversationHistory.removeSubrange(removeStart..<(removeStart + messagesToEvict))
                NSLog("CyclopOne [AgentLoop]: Evicted %d messages (%d complete cycles), history now %d messages",
                      messagesToEvict, cyclesToEvict, conversationHistory.count)
            }
        }

        // Safety net: clean up any orphans that may exist from earlier bugs or edge cases.
        removeOrphanedToolResults()
        removeOrphanedToolUses()

        // Always prune — even early iterations benefit from smaller payloads

        // Find all message indices that contain image content blocks
        var imageMessageIndices: [Int] = []
        for (index, message) in conversationHistory.enumerated() {
            if messageContainsImage(message) {
                imageMessageIndices.append(index)
            }
        }

        // Keep the most recent screenshotPruneThreshold images, prune the rest
        let countToPreserve = screenshotPruneThreshold
        guard imageMessageIndices.count > countToPreserve else { return }

        let indicesToPrune = imageMessageIndices.dropLast(countToPreserve)
        var prunedBytes = 0

        for index in indicesToPrune {
            let (pruned, bytesRemoved) = pruneImageFromMessage(conversationHistory[index])
            conversationHistory[index] = pruned
            prunedBytes += bytesRemoved
        }

        if prunedBytes > 0 {
            let prunedKB = prunedBytes / 1024
            print("[AgentLoop] Pruned \(indicesToPrune.count) old screenshots from conversation history (~\(prunedKB)KB freed)")
        }
    }

    /// Remove mismatched tool_use / tool_result cycles from conversation history.
    ///
    /// The Claude API enforces strict pairing: every tool_use block in an assistant
    /// message at index `i` must have a matching tool_result (by ID) in the
    /// immediately following user message at index `i+1`, and vice versa. The sets
    /// of IDs must be identical.
    ///
    /// After pruning evicts messages from the middle of the history, these pairs
    /// can become broken. This method detects any broken cycle and removes both
    /// the assistant and user messages involved. Because removing a cycle shifts
    /// subsequent indices and can create new mismatches (e.g. an unrelated user
    /// message with tool_results now sits after a plain assistant message), the
    /// scan repeats until a full pass finds no violations.
    private func removeOrphanedToolResults() {
        var totalRemoved = 0

        // Iterate until stable -- each removal pass can expose new mismatches.
        while true {
            var indicesToRemove = Set<Int>()

            var i = 0
            while i < conversationHistory.count {
                let message = conversationHistory[i]
                guard let role = message["role"] as? String else { i += 1; continue }

                if role == "assistant" {
                    let toolUseIDs = extractToolUseIDs(from: message)
                    if toolUseIDs.isEmpty { i += 1; continue }

                    // An assistant message with tool_use MUST be followed by a user
                    // message whose tool_result IDs exactly match.
                    let nextIndex = i + 1
                    var matched = false
                    if nextIndex < conversationHistory.count {
                        let nextMessage = conversationHistory[nextIndex]
                        let nextRole = nextMessage["role"] as? String ?? ""
                        let toolResultIDs = extractToolResultIDs(from: nextMessage)
                        if nextRole == "user" && toolUseIDs == toolResultIDs {
                            matched = true
                        }
                    }

                    if !matched {
                        indicesToRemove.insert(i)
                        // If the next message is a user message with tool_results that
                        // don't match, it is also orphaned -- remove it too.
                        if nextIndex < conversationHistory.count {
                            let nextMessage = conversationHistory[nextIndex]
                            let nextRole = nextMessage["role"] as? String ?? ""
                            if nextRole == "user" && !extractToolResultIDs(from: nextMessage).isEmpty {
                                indicesToRemove.insert(nextIndex)
                            }
                        }
                    }
                } else if role == "user" {
                    let toolResultIDs = extractToolResultIDs(from: message)
                    if toolResultIDs.isEmpty { i += 1; continue }

                    // A user message with tool_results MUST be preceded by an assistant
                    // message whose tool_use IDs exactly match.
                    let prevIndex = i - 1
                    var matched = false
                    if prevIndex >= 0 {
                        let prevMessage = conversationHistory[prevIndex]
                        let prevRole = prevMessage["role"] as? String ?? ""
                        let toolUseIDs = extractToolUseIDs(from: prevMessage)
                        if prevRole == "assistant" && toolUseIDs == toolResultIDs {
                            matched = true
                        }
                    }

                    if !matched {
                        indicesToRemove.insert(i)
                        // If the preceding message is an assistant with tool_uses that
                        // don't match, it is also orphaned -- remove it too.
                        if prevIndex >= 0 {
                            let prevMessage = conversationHistory[prevIndex]
                            let prevRole = prevMessage["role"] as? String ?? ""
                            if prevRole == "assistant" && !extractToolUseIDs(from: prevMessage).isEmpty {
                                indicesToRemove.insert(prevIndex)
                            }
                        }
                    }
                }

                i += 1
            }

            if indicesToRemove.isEmpty { break }

            // Remove in reverse index order to keep lower indices stable.
            for idx in indicesToRemove.sorted(by: >) {
                conversationHistory.remove(at: idx)
            }
            totalRemoved += indicesToRemove.count
        }

        if totalRemoved > 0 {
            NSLog("CyclopOne [AgentLoop]: Removed %d messages with mismatched tool_use/tool_result cycles", totalRemoved)
        }
    }

    /// Remove assistant messages with orphaned tool_use blocks.
    ///
    /// NOTE: All orphan cleanup is now handled by `removeOrphanedToolResults()`,
    /// which validates complete cycles in both directions and iterates until
    /// stable. This method is kept to preserve the call-site contract in
    /// `pruneConversationHistory()`.
    private func removeOrphanedToolUses() {
        // Intentionally empty -- removeOrphanedToolResults() handles both
        // directions (tool_use -> tool_result and tool_result -> tool_use)
        // and iterates until no mismatches remain.
    }

    /// Extract the set of tool_use IDs from an assistant message's content blocks.
    private func extractToolUseIDs(from message: [String: Any]) -> Set<String> {
        guard let content = message["content"] as? [[String: Any]] else { return [] }
        var ids = Set<String>()
        for block in content {
            if let type = block["type"] as? String, type == "tool_use",
               let id = block["id"] as? String {
                ids.insert(id)
            }
        }
        return ids
    }

    /// Extract the set of tool_use_id references from tool_result blocks in a user message.
    private func extractToolResultIDs(from message: [String: Any]) -> Set<String> {
        guard let content = message["content"] as? [[String: Any]] else { return [] }
        var ids = Set<String>()
        for block in content {
            if let type = block["type"] as? String, type == "tool_result",
               let toolUseId = block["tool_use_id"] as? String {
                ids.insert(toolUseId)
            }
        }
        return ids
    }

    /// Validate that every tool_use block has a matching tool_result and vice versa.
    ///
    /// Conversation history can become corrupted when pruning evicts one half of a
    /// tool_use / tool_result pair. The Claude API rejects such payloads. This method
    /// scans the full history, identifies mismatched pairs, removes the orphaned
    /// messages, and logs a warning.
    ///
    /// - Returns: `true` if the history was already valid; `false` if repairs were needed.
    @discardableResult
    func validateConversationHistory() -> Bool {
        // 1. Collect all tool_use IDs from assistant messages.
        var toolUseIDs = Set<String>()
        for message in conversationHistory {
            guard let role = message["role"] as? String, role == "assistant" else { continue }
            guard let content = message["content"] as? [[String: Any]] else { continue }
            for block in content {
                if let type = block["type"] as? String, type == "tool_use",
                   let id = block["id"] as? String {
                    toolUseIDs.insert(id)
                }
            }
        }

        // 2. Collect all tool_result tool_use_ids from user messages.
        var toolResultIDs = Set<String>()
        for message in conversationHistory {
            guard let role = message["role"] as? String, role == "user" else { continue }
            guard let content = message["content"] as? [[String: Any]] else { continue }
            for block in content {
                if let type = block["type"] as? String, type == "tool_result",
                   let toolUseId = block["tool_use_id"] as? String {
                    toolResultIDs.insert(toolUseId)
                }
            }
        }

        // 3. Find mismatches in both directions.
        let toolUsesWithoutResults = toolUseIDs.subtracting(toolResultIDs)
        let toolResultsWithoutUses = toolResultIDs.subtracting(toolUseIDs)

        // If everything matches, history is valid.
        if toolUsesWithoutResults.isEmpty && toolResultsWithoutUses.isEmpty {
            return true
        }

        // 4. Log warnings for each mismatch.
        if !toolUsesWithoutResults.isEmpty {
            NSLog("CyclopOne [validateConversationHistory]: WARNING — %d tool_use blocks without matching tool_result: %@",
                  toolUsesWithoutResults.count,
                  toolUsesWithoutResults.sorted().joined(separator: ", "))
        }
        if !toolResultsWithoutUses.isEmpty {
            NSLog("CyclopOne [validateConversationHistory]: WARNING — %d tool_result blocks without matching tool_use: %@",
                  toolResultsWithoutUses.count,
                  toolResultsWithoutUses.sorted().joined(separator: ", "))
        }

        // 5a. Remove assistant messages that contain any orphaned tool_use.
        //     We must remove the entire message because partial tool_use removal
        //     can leave the message in an inconsistent state.
        var assistantIndicesToRemove: [Int] = []
        for (i, message) in conversationHistory.enumerated() {
            guard let role = message["role"] as? String, role == "assistant" else { continue }
            guard let content = message["content"] as? [[String: Any]] else { continue }
            let hasOrphaned = content.contains { block in
                guard let type = block["type"] as? String, type == "tool_use",
                      let id = block["id"] as? String else { return false }
                return toolUsesWithoutResults.contains(id)
            }
            if hasOrphaned {
                assistantIndicesToRemove.append(i)
            }
        }

        // 5b. Remove user messages (or filter blocks) for orphaned tool_results.
        var userIndicesToRemove: [Int] = []
        for (i, message) in conversationHistory.enumerated() {
            guard let role = message["role"] as? String, role == "user" else { continue }
            guard let content = message["content"] as? [[String: Any]] else { continue }

            let hasOrphanedResults = content.contains { block in
                guard let type = block["type"] as? String, type == "tool_result",
                      let toolUseId = block["tool_use_id"] as? String else { return false }
                return toolResultsWithoutUses.contains(toolUseId)
            }
            guard hasOrphanedResults else { continue }

            // Check if ALL blocks are orphaned tool_results — if so, remove entire message.
            let allOrphaned = content.allSatisfy { block in
                guard let type = block["type"] as? String, type == "tool_result",
                      let toolUseId = block["tool_use_id"] as? String else { return false }
                return toolResultsWithoutUses.contains(toolUseId)
            }

            if allOrphaned {
                userIndicesToRemove.append(i)
            } else {
                // Filter out only the orphaned tool_result blocks, keep the rest.
                let filtered = content.filter { block in
                    guard let type = block["type"] as? String, type == "tool_result",
                          let toolUseId = block["tool_use_id"] as? String else { return true }
                    return !toolResultsWithoutUses.contains(toolUseId)
                }
                var modified = message
                modified["content"] = filtered
                conversationHistory[i] = modified
            }
        }

        // Remove fully orphaned messages in reverse index order to preserve indices.
        let allIndicesToRemove = Set(assistantIndicesToRemove).union(Set(userIndicesToRemove))
        for i in allIndicesToRemove.sorted().reversed() {
            conversationHistory.remove(at: i)
        }

        let totalRemoved = allIndicesToRemove.count
        if totalRemoved > 0 {
            NSLog("CyclopOne [validateConversationHistory]: Removed %d messages with broken tool pairs, history now %d messages",
                  totalRemoved, conversationHistory.count)
        }

        return false
    }

    /// Check if a conversation message contains image content (base64 screenshot data).
    func messageContainsImage(_ message: [String: Any]) -> Bool {
        guard let content = message["content"] else { return false }

        // Handle array-style content blocks (user messages, tool results)
        if let contentArray = content as? [[String: Any]] {
            return contentArray.contains { block in
                if let type = block["type"] as? String, type == "image" {
                    return true
                }
                // Check nested tool_result content blocks
                if let innerContent = block["content"] as? [[String: Any]] {
                    return innerContent.contains { inner in
                        (inner["type"] as? String) == "image"
                    }
                }
                return false
            }
        }

        return false
    }

    /// Replace image content blocks in a message with placeholder text.
    /// Returns the modified message and the approximate number of bytes removed.
    func pruneImageFromMessage(_ message: [String: Any]) -> ([String: Any], Int) {
        var modified = message
        var bytesRemoved = 0

        guard let content = message["content"] as? [[String: Any]] else {
            return (modified, 0)
        }

        var newContent: [[String: Any]] = []

        for block in content {
            if let type = block["type"] as? String, type == "image" {
                // Estimate the size of the base64 data being removed
                if let source = block["source"] as? [String: Any],
                   let data = source["data"] as? String {
                    bytesRemoved += data.utf8.count
                }
                // Replace with placeholder text block
                newContent.append([
                    "type": "text",
                    "text": "[screenshot removed]"
                ])
            } else if let innerContent = block["content"] as? [[String: Any]] {
                // Handle tool_result content blocks with nested images
                var newInnerContent: [[String: Any]] = []
                for inner in innerContent {
                    if let type = inner["type"] as? String, type == "image" {
                        if let source = inner["source"] as? [String: Any],
                           let data = source["data"] as? String {
                            bytesRemoved += data.utf8.count
                        }
                        newInnerContent.append([
                            "type": "text",
                            "text": "[screenshot removed]"
                        ])
                    } else {
                        newInnerContent.append(inner)
                    }
                }
                var modifiedBlock = block
                modifiedBlock["content"] = newInnerContent
                newContent.append(modifiedBlock)
            } else {
                newContent.append(block)
            }
        }

        modified["content"] = newContent
        return (modified, bytesRemoved)
    }

    /// Sprint 19: Get the approximate payload size of the current conversation history in bytes.
    /// Useful for monitoring and debugging payload growth.
    func conversationPayloadSize() -> Int {
        guard let data = try? JSONSerialization.data(withJSONObject: conversationHistory) else {
            return 0
        }
        return data.count
    }

    /// Sprint 18: Set skill context to inject into the system prompt for this run.
    func setSkillContext(_ context: String) {
        self.skillContext = context
    }

    /// Set memory context to inject into the system prompt for this run.
    func setMemoryContext(_ context: String) {
        self.memoryContext = context
    }

    /// Set the current step instruction for this run.
    /// Called by the Orchestrator at the start of each plan step.
    /// Replaces the old `setBrainPlan()` method.
    func setCurrentStepInstruction(_ instruction: String) {
        self.currentStepInstruction = instruction
    }

    /// Sprint 16: Restore conversation history from a replayed run state.
    ///
    /// Called by `Orchestrator.resumeRun(runId:)` to set up the agent's
    /// conversation context before resuming from the last committed iteration.
    /// Builds a synthetic conversation from the original user command and
    /// any tool calls/results recorded in the journal.
    ///
    /// - Parameters:
    ///   - command: The original user command text.
    ///   - completionToken: The new completion token for the resumed run.
    ///   - toolEvents: Tool execution events from the journal replay.
    ///   - screenshot: A fresh screenshot taken after relaunch.
    func restoreForResume(
        command: String,
        completionToken: String,
        toolEvents: [(tool: String, result: String?)],
        screenshot: ScreenCapture?
    ) async {
        isCancelled = false
        conversationHistory.removeAll()
        self.completionToken = completionToken
        consecutiveAPIFailures = 0
        iterationCount = 0  // Reset so prepareRun's work isn't wasted
        recentToolCallFingerprints.removeAll()
        latestScreenshot = screenshot

        // Build the initial user message with the fresh screenshot
        var enhancedMessage = command
        if let ss = screenshot {
            enhancedMessage += "\n\n[Resumed after crash. Screenshot: \(ss.width)x\(ss.height)px. Actual screen: \(ss.screenWidth)x\(ss.screenHeight) points. Provide coordinates in screenshot pixel space.]"
        } else {
            enhancedMessage += "\n\n[Resumed after crash. No screenshot available.]"
        }

        // Read UI tree for the target app, not Cyclop One
        let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)

        let userMsg = ClaudeAPIService.buildUserMessage(
            text: enhancedMessage,
            screenshot: screenshot,
            uiTreeSummary: uiTree
        )
        conversationHistory.append(userMsg)

        // Reconstruct tool call/result pairs from journal events
        // This gives Claude context about what was already done before the crash
        if !toolEvents.isEmpty {
            // Build a synthetic assistant message summarizing previous work
            var summaryParts: [String] = ["[Previous actions before interruption:]"]
            for (i, event) in toolEvents.enumerated() {
                let resultText = event.result ?? "completed"
                summaryParts.append("\(i + 1). \(event.tool): \(resultText)")
            }
            let summaryText = summaryParts.joined(separator: "\n")

            let assistantMsg: [String: Any] = [
                "role": "assistant",
                "content": [
                    ["type": "text", "text": summaryText]
                ]
            ]
            conversationHistory.append(assistantMsg)

            // Add a user message indicating resume
            let resumeMsg = ClaudeAPIService.buildUserMessage(
                text: "The task was interrupted. Please continue from where you left off. Take a fresh screenshot to assess the current state before proceeding.",
                screenshot: screenshot,
                uiTreeSummary: uiTree
            )
            conversationHistory.append(resumeMsg)
        }
    }

    func updateConfig(_ newConfig: AgentConfig) {
        self.config = newConfig
    }

    // MARK: - Coordinate Mapping

    private func mapToScreen(x: Double, y: Double) -> (x: Double, y: Double) {
        guard let ss = latestScreenshot else { return (x, y) }
        return ss.toScreenCoords(x: x, y: y)
    }

    /// Ensure the target application is still the frontmost app before each iteration.
    /// If another app stole focus (e.g. Chrome, Finder), re-activate the target app.
    /// This prevents the agent from interacting with the wrong app mid-task.
    private func ensureTargetAppFocused() async {
        guard let targetPID = self.targetAppPID else { return }

        let currentPID = ProcessInfo.processInfo.processIdentifier
        let frontPID = await MainActor.run {
            NSWorkspace.shared.frontmostApplication?.processIdentifier
        }

        // If Cyclop One itself is frontmost, or a different app stole focus, re-activate target
        if let front = frontPID, front != targetPID {
            let frontName = await MainActor.run {
                NSWorkspace.shared.frontmostApplication?.localizedName ?? "unknown"
            }
            let targetName = await MainActor.run {
                NSRunningApplication(processIdentifier: targetPID)?.localizedName ?? "unknown"
            }

            // Only log and re-focus if a non-Cyclop One app stole focus
            // (Cyclop One steals focus naturally during screenshot/panel operations)
            if front != currentPID {
                NSLog("CyclopOne [AgentLoop]: Focus stolen by '%@' (PID %d), re-activating target '%@' (PID %d)",
                      frontName, front, targetName, targetPID)
            }

            await activateTargetApp()
            // Brief settle time after re-activation
            try? await Task.sleep(nanoseconds: 150_000_000) // 150ms
        }
    }

    /// Update targetAppPID from the current frontmost application.
    /// Called after clicks and app launches with a delay to let activation settle.
    private func updateTargetPID() async {
        try? await Task.sleep(nanoseconds: 200_000_000) // 200ms for activation
        let newPID = await MainActor.run { () -> pid_t? in
            let currentPID = ProcessInfo.processInfo.processIdentifier
            if let front = NSWorkspace.shared.frontmostApplication,
               front.processIdentifier != currentPID {
                return front.processIdentifier
            }
            return nil
        }
        if let pid = newPID { targetAppPID = pid }
    }

    // MARK: - M5: Safety Gate Interface

    func startSafetyGateRun(runId: String) async {
        await safetyGate.startRun(runId: runId)
    }

    func endSafetyGateRun() async {
        await safetyGate.endRun()
    }

    /// Build the ActionContext from current system state.
    private func gatherActionContext() async -> ActionSafetyGate.ActionContext {
        let appInfo = await MainActor.run { [targetAppPID] () -> (name: String?, bundleID: String?) in
            guard let pid = targetAppPID,
                  let app = NSRunningApplication(processIdentifier: pid) else {
                return (nil, nil)
            }
            return (app.localizedName, app.bundleIdentifier)
        }

        let focusInfo = await MainActor.run { [targetAppPID, accessibility] () -> (role: String, label: String)? in
            return accessibility.getFocusedElementInfo(targetPID: targetAppPID)
        }

        let windowTitle = await MainActor.run { [targetAppPID, accessibility] () -> String? in
            return accessibility.getWindowTitle(targetPID: targetAppPID)
        }

        let currentURL: String?
        if let bundleID = appInfo.bundleID,
           ["com.apple.Safari", "com.google.Chrome", "org.mozilla.firefox",
            "com.microsoft.edgemac", "com.brave.Browser", "company.thebrowser.Browser"]
            .contains(bundleID) {
            currentURL = await MainActor.run { [targetAppPID, accessibility] () -> String? in
                return accessibility.getBrowserURL(targetPID: targetAppPID)
            }
        } else {
            currentURL = nil
        }

        return ActionSafetyGate.ActionContext(
            activeAppName: appInfo.name,
            activeAppBundleID: appInfo.bundleID,
            windowTitle: windowTitle,
            focusedElementRole: focusInfo?.role,
            focusedElementLabel: focusInfo?.label,
            recentToolCalls: Array(recentToolCallHistory.suffix(3)),
            currentURL: currentURL
        )
    }

    // MARK: - Observer Helpers

    /// Execute an observer callback with a timeout. If the observer call takes
    /// longer than `timeout` seconds, it is cancelled and a warning is logged.
    /// This prevents slow network I/O (e.g. Telegram API) from stalling the agent loop.
    private static func fireAndForgetObserver(
        timeout: TimeInterval,
        body: @Sendable @escaping () async -> Void
    ) async {
        await withTaskGroup(of: Void.self) { group in
            group.addTask {
                await body()
            }
            group.addTask {
                try? await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
            }
            // Wait for whichever finishes first
            await group.next()
            // Cancel the other
            group.cancelAll()
        }
    }

    // MARK: - Tool Execution

    private func executeToolCall(
        name: String,
        input: [String: Any],
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void,
        onConfirmationNeeded: @Sendable @escaping (String) async -> Bool
    ) async -> ToolResult {

        // M6: Early cancellation check
        guard !Task.isCancelled else {
            return ToolResult(result: "Cancelled", isError: false)
        }

        onStateChange(.executing(name))

        // ── M5: Safety Gate ──
        if config.confirmDestructiveActions {
            let context = await gatherActionContext()
            let stringInput = input.reduce(into: [String: String]()) { result, pair in
                if let str = pair.value as? String {
                    result[pair.key] = str
                } else if let num = pair.value as? NSNumber {
                    result[pair.key] = num.stringValue
                } else {
                    result[pair.key] = String(describing: pair.value)
                }
            }
            let toolCall = ActionSafetyGate.ToolCall(
                name: name,
                input: stringInput,
                iteration: iterationCount,
                stepInstruction: currentStepInstruction.isEmpty ? nil : currentStepInstruction
            )
            let verdict = await safetyGate.evaluate(toolCall: toolCall, context: context)

            switch verdict.level {
            case .safe:
                break

            case .moderate:
                NSLog("CyclopOne [SafetyGate]: MODERATE -- %@ -- %@", name, verdict.reason)

            case .high:
                onStateChange(.awaitingConfirmation(verdict.reason))
                let approved = await onConfirmationNeeded(verdict.approvalPrompt ?? "Approve \(name)?")
                if !approved {
                    await safetyGate.recordSessionApproval("denied:\(name)", approved: false)
                    return ToolResult(result: "Action denied by user: \(verdict.reason)", isError: false)
                }
                if let cacheKey = verdict.sessionCacheKey {
                    await safetyGate.recordSessionApproval(cacheKey, approved: true)
                }

            case .critical:
                onStateChange(.awaitingConfirmation("CRITICAL: \(verdict.reason)"))
                let approved = await onConfirmationNeeded(
                    verdict.approvalPrompt ?? "CRITICAL ACTION: \(name)\n\n\(verdict.reason)"
                )
                if !approved {
                    return ToolResult(result: "Critical action denied by user: \(verdict.reason)", isError: false)
                }
            }
        }

        // ── Proceed to tool execution ──
        switch name {

        case "run_shell_command":
            guard let command = input["command"] as? String else {
                return ToolResult(result: "Error: missing 'command'", isError: true)
            }
            do {
                let result = try await executor.runShellCommand(command, timeout: config.shellTimeout)
                onMessage(ChatMessage(role: .toolResult, content: "$ \(command)\n\(result.summary)"))
                return ToolResult(result: result.summary, isError: !result.isSuccess)
            } catch {
                return ToolResult(result: "Error: \(error.localizedDescription)", isError: true)
            }

        case "run_applescript":
            guard let script = input["script"] as? String else {
                return ToolResult(result: "Error: missing 'script'", isError: true)
            }
            do {
                let result = try await executor.runAppleScript(script)

                // If the script activated an app, update our target
                if script.lowercased().contains("activate") {
                    await updateTargetPID()
                }

                return ToolResult(result: "AppleScript: \(result)", isError: false)
            } catch {
                return ToolResult(result: "Error: \(error.localizedDescription)", isError: true)
            }

        case "click", "right_click":
            guard let rawX = input["x"] as? Double, let rawY = input["y"] as? Double else {
                return ToolResult(result: "Error: missing x/y", isError: true)
            }
            let isDouble = input["double_click"] as? Bool ?? false
            let isRight = (name == "right_click")
            let (sx, sy) = mapToScreen(x: rawX, y: rawY)

            // Sprint 7: Read configurable timing from executor
            let timing = await executor.timing

            // CRITICAL: Activate target app and let clicks through panel
            await activateTargetApp()
            await letClicksThrough()

            // Move mouse first (some apps need this), then click
            await accessibility.moveMouse(x: sx, y: sy)
            try? await Task.sleep(nanoseconds: timing.clickDelayBefore)

            let clickResult: AccessibilityService.ActionResult
            if isRight {
                clickResult = await accessibility.rightClickAt(x: sx, y: sy)
            } else if isDouble {
                clickResult = await accessibility.doubleClickAt(x: sx, y: sy)
            } else {
                clickResult = await accessibility.clickAt(x: sx, y: sy)
            }

            // Wait for the target app to process the click
            try? await Task.sleep(nanoseconds: timing.clickDelayAfter)

            await stopClicksThrough()

            // Update target to whatever app is now frontmost
            await updateTargetPID()

            if !clickResult.success {
                return ToolResult(result: "Error: \(clickResult.error ?? "click failed")", isError: true)
            }

            let clickType = isRight ? "Right-clicked" : (isDouble ? "Double-clicked" : "Clicked")
            return ToolResult(result: "\(clickType) at screenshot(\(Int(rawX)),\(Int(rawY))) → screen(\(Int(sx)),\(Int(sy)))", isError: false)

        case "type_text":
            guard let text = input["text"] as? String else {
                return ToolResult(result: "Error: missing 'text'", isError: true)
            }

            // Sprint 7: Read configurable timing from executor
            let typeTiming = await executor.timing

            // CRITICAL: Activate target app so keystrokes go to it, not our panel
            await activateTargetApp()

            let typeResult = await accessibility.typeText(text)

            if !typeResult.success {
                return ToolResult(result: "Error: \(typeResult.error ?? "typing failed")", isError: true)
            }

            // Wait for typing to complete (configurable per-char delay)
            let typingTime = UInt64(text.count) * typeTiming.typingDelayPerChar
            try? await Task.sleep(nanoseconds: max(typingTime, typeTiming.typingMinSettle))
            return ToolResult(result: "Typed: \(text.prefix(100))\(text.count > 100 ? "…" : "")", isError: false)

        case "press_key":
            guard let keyName = input["key"] as? String else {
                return ToolResult(result: "Error: missing 'key'", isError: true)
            }
            guard let keyCode = ActionExecutor.keyCodes[keyName.lowercased()] else {
                return ToolResult(result: "Error: unknown key '\(keyName)'", isError: true)
            }
            let cmd = input["command"] as? Bool ?? false
            let shift = input["shift"] as? Bool ?? false
            let opt = input["option"] as? Bool ?? false
            let ctrl = input["control"] as? Bool ?? false

            // CRITICAL: Activate target app so key presses go to it
            await activateTargetApp()

            var flags = CGEventFlags()
            if cmd { flags.insert(.maskCommand) }
            if shift { flags.insert(.maskShift) }
            if opt { flags.insert(.maskAlternate) }
            if ctrl { flags.insert(.maskControl) }
            let keyResult = await accessibility.pressShortcut(keyCode: keyCode, modifiers: flags)

            if !keyResult.success {
                return ToolResult(result: "Error: \(keyResult.error ?? "key press failed")", isError: true)
            }

            // Sprint 7: Configurable key press delay
            let keyTiming = await executor.timing
            try? await Task.sleep(nanoseconds: keyTiming.keyPressDelay)

            var desc = keyName
            if cmd { desc = "⌘+" + desc }
            if shift { desc = "⇧+" + desc }
            if opt { desc = "⌥+" + desc }
            if ctrl { desc = "⌃+" + desc }
            return ToolResult(result: "Pressed: \(desc)", isError: false)

        case "take_screenshot":
            // Only screenshots need full hide (so panel doesn't appear in image)
            NSLog("CyclopOne [AgentLoop]: take_screenshot — hiding panel for capture (maxDim=%d, quality=%.2f)",
                  config.screenshotMaxDimension, config.screenshotJPEGQuality)
            await hideForScreenshot()

            do {
                let ss = try await capture.captureScreen(
                    maxDimension: config.screenshotMaxDimension,
                    quality: config.screenshotJPEGQuality
                )
                latestScreenshot = ss

                NSLog("CyclopOne [take_screenshot]: %dx%d px, %@, base64=%d chars, data=%d bytes",
                      ss.width, ss.height, ss.mediaType, ss.base64.count, ss.imageData.count)
                // Save diagnostic copy for debugging
                let ext = ss.mediaType == "image/png" ? "png" : "jpg"
                try? ss.imageData.write(to: URL(fileURLWithPath: "/tmp/cyclopone_last_sent.\(ext)"))
                NSLog("CyclopOne [take_screenshot]: Diagnostic saved to /tmp/cyclopone_last_sent.%@", ext)

                // Read UI tree for the TARGET app, not Cyclop One
                let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)

                await showAfterScreenshot()

                // CRITICAL: include the screenshot image so Claude can SEE the result
                return ToolResult(
                    result: "Screenshot (\(ss.width)x\(ss.height), \(ss.mediaType), screen \(ss.screenWidth)x\(ss.screenHeight)).\nUI:\n\(uiTree)",
                    isError: false,
                    screenshot: ss
                )
            } catch {
                await showAfterScreenshot()
                return ToolResult(result: "Screenshot failed: \(error.localizedDescription)", isError: true)
            }

        case "open_application":
            guard let appName = input["name"] as? String else {
                return ToolResult(result: "Error: missing 'name'", isError: true)
            }
            do {
                let result = try await executor.openApplication(appName)
                try? await Task.sleep(nanoseconds: 1_500_000_000) // 1.5s for app launch

                // Update target to the newly opened/activated app
                let newPID = await MainActor.run { () -> pid_t? in
                    let currentPID = ProcessInfo.processInfo.processIdentifier
                    // Try to find the app by name first
                    if let app = NSWorkspace.shared.runningApplications.first(where: {
                        $0.localizedName?.lowercased() == appName.lowercased() &&
                        $0.processIdentifier != currentPID
                    }) {
                        return app.processIdentifier
                    }
                    // Fallback: whatever is now frontmost
                    if let front = NSWorkspace.shared.frontmostApplication,
                       front.processIdentifier != currentPID {
                        return front.processIdentifier
                    }
                    return nil
                }
                if let pid = newPID { targetAppPID = pid }

                // Auto-capture screenshot after opening so Claude can see the result
                await hideForScreenshot()
                var postScreenshot: ScreenCapture? = nil
                if let ss = try? await capture.captureScreen(
                    maxDimension: config.screenshotMaxDimension,
                    quality: config.screenshotJPEGQuality
                ) {
                    latestScreenshot = ss
                    postScreenshot = ss
                    let ext = ss.mediaType == "image/png" ? "png" : "jpg"
                    try? ss.imageData.write(to: URL(fileURLWithPath: "/tmp/cyclopone_last_sent.\(ext)"))
                }
                await showAfterScreenshot()

                let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)
                let screenshotInfo = postScreenshot.map { "Screenshot: \($0.width)x\($0.height)px" } ?? "No screenshot"
                return ToolResult(
                    result: "Opened \(appName): \(result). \(screenshotInfo)\nUI:\n\(uiTree)",
                    isError: false,
                    screenshot: postScreenshot
                )
            } catch {
                return ToolResult(result: "Error: \(error.localizedDescription)", isError: true)
            }

        case "open_url":
            guard let urlString = input["url"] as? String else {
                return ToolResult(result: "Error: missing 'url'", isError: true)
            }
            guard let url = URL(string: urlString), url.scheme != nil else {
                return ToolResult(result: "Error: invalid URL '\(urlString)'. Must include protocol (https:// or http://).", isError: true)
            }
            let browserName = input["browser"] as? String

            do {
                // Open URL in specified browser or default
                let opened: Bool
                if let browser = browserName {
                    // Open in specific browser using shell command
                    _ = try await executor.runShellCommand("open -a \"\(browser)\" \"\(urlString)\"", timeout: 10)
                    opened = true
                } else {
                    // Open in default browser via NSWorkspace
                    opened = await MainActor.run {
                        NSWorkspace.shared.open(url)
                    }
                }

                guard opened else {
                    return ToolResult(result: "Error: failed to open URL '\(urlString)'", isError: true)
                }

                // Wait for the browser to activate and page to start loading
                try? await Task.sleep(nanoseconds: 2_500_000_000) // 2.5s for page load

                // Update target to the browser
                await updateTargetPID()

                // Auto-capture screenshot after page loads
                await hideForScreenshot()
                var postScreenshot: ScreenCapture? = nil
                if let ss = try? await capture.captureScreen(
                    maxDimension: config.screenshotMaxDimension,
                    quality: config.screenshotJPEGQuality
                ) {
                    latestScreenshot = ss
                    postScreenshot = ss
                    let ext = ss.mediaType == "image/png" ? "png" : "jpg"
                    try? ss.imageData.write(to: URL(fileURLWithPath: "/tmp/cyclopone_last_sent.\(ext)"))
                }
                await showAfterScreenshot()

                let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)
                let screenshotInfo = postScreenshot.map { "Screenshot: \($0.width)x\($0.height)px" } ?? "No screenshot"
                return ToolResult(
                    result: "Opened URL \(urlString) in \(browserName ?? "default browser"). \(screenshotInfo)\nUI:\n\(uiTree)",
                    isError: false,
                    screenshot: postScreenshot
                )
            } catch {
                return ToolResult(result: "Error opening URL: \(error.localizedDescription)", isError: true)
            }

        case "move_mouse":
            guard let rawX = input["x"] as? Double, let rawY = input["y"] as? Double else {
                return ToolResult(result: "Error: missing x/y", isError: true)
            }
            let (sx, sy) = mapToScreen(x: rawX, y: rawY)
            await activateTargetApp()
            await letClicksThrough()
            await accessibility.moveMouse(x: sx, y: sy)
            try? await Task.sleep(nanoseconds: 200_000_000)
            await stopClicksThrough()
            return ToolResult(result: "Moved to screen(\(Int(sx)),\(Int(sy)))", isError: false)

        case "drag":
            guard let fX = input["from_x"] as? Double, let fY = input["from_y"] as? Double,
                  let tX = input["to_x"] as? Double, let tY = input["to_y"] as? Double else {
                return ToolResult(result: "Error: missing coordinates", isError: true)
            }
            let (sx1, sy1) = mapToScreen(x: fX, y: fY)
            let (sx2, sy2) = mapToScreen(x: tX, y: tY)

            await activateTargetApp()
            await letClicksThrough()
            await accessibility.drag(fromX: sx1, fromY: sy1, toX: sx2, toY: sy2)
            try? await Task.sleep(nanoseconds: 300_000_000)
            await stopClicksThrough()
            return ToolResult(result: "Dragged (\(Int(sx1)),\(Int(sy1))) → (\(Int(sx2)),\(Int(sy2)))", isError: false)

        case "scroll":
            guard let rawX = input["x"] as? Double, let rawY = input["y"] as? Double else {
                return ToolResult(result: "Error: missing x/y", isError: true)
            }
            let deltaY = input["delta_y"] as? Int ?? -3
            let (sx, sy) = mapToScreen(x: rawX, y: rawY)

            await activateTargetApp()
            await letClicksThrough()
            await accessibility.scroll(x: sx, y: sy, deltaY: deltaY)
            try? await Task.sleep(nanoseconds: 200_000_000)
            await stopClicksThrough()
            return ToolResult(result: "Scrolled \(deltaY > 0 ? "up" : "down") \(abs(deltaY)) at (\(Int(sx)),\(Int(sy)))", isError: false)

        // ── Vault Management Tools ──

        case "vault_read":
            guard let path = input["path"] as? String else {
                return ToolResult(result: "Error: missing 'path'", isError: true)
            }
            let content = await MemoryService.shared.readNote(at: path)
            return ToolResult(result: content ?? "Note not found: \(path)", isError: content == nil)

        case "vault_write":
            guard let path = input["path"] as? String,
                  let content = input["content"] as? String else {
                return ToolResult(result: "Error: missing 'path' or 'content'", isError: true)
            }
            do {
                try await MemoryService.shared.writeNote(at: path, content: content)
                return ToolResult(result: "Wrote note: \(path)", isError: false)
            } catch {
                return ToolResult(result: "Error writing note: \(error.localizedDescription)", isError: true)
            }

        case "vault_append":
            guard let path = input["path"] as? String,
                  let content = input["content"] as? String else {
                return ToolResult(result: "Error: missing 'path' or 'content'", isError: true)
            }
            do {
                try await MemoryService.shared.appendToNote(at: path, text: content)
                return ToolResult(result: "Appended to note: \(path)", isError: false)
            } catch {
                return ToolResult(result: "Error appending to note: \(error.localizedDescription)", isError: true)
            }

        case "vault_search":
            guard let query = input["query"] as? String else {
                return ToolResult(result: "Error: missing 'query'", isError: true)
            }
            let folder = input["directory"] as? String
            let limit = input["limit"] as? Int ?? 10
            let results = await MemoryService.shared.searchNotes(query: query, folder: folder, limit: limit)
            if results.isEmpty {
                return ToolResult(result: "No notes found matching: \(query)", isError: false)
            }
            let formatted = results.map { "**\($0.path)**: \($0.snippet)" }.joined(separator: "\n\n")
            return ToolResult(result: formatted, isError: false)

        case "vault_list":
            let directory = input["directory"] as? String ?? ""
            let items = await MemoryService.shared.listNotes(in: directory)
            if items.isEmpty {
                return ToolResult(result: "Directory is empty or does not exist: \(directory)", isError: false)
            }
            return ToolResult(result: items.joined(separator: "\n"), isError: false)

        // ── Task Management Tools ──

        case "task_create":
            guard let title = input["title"] as? String else {
                return ToolResult(result: "Error: missing 'title'", isError: true)
            }
            let details = input["details"] as? String ?? ""
            let priority = input["priority"] as? String ?? "medium"
            let project = input["project"] as? String
            do {
                let path = try await MemoryService.shared.createTask(
                    title: title, description: details,
                    priority: priority, project: project
                )
                return ToolResult(result: "Created task: \(title) at \(path)", isError: false)
            } catch {
                return ToolResult(result: "Error creating task: \(error.localizedDescription)", isError: true)
            }

        case "task_update":
            guard let title = input["title"] as? String,
                  let status = input["status"] as? String else {
                return ToolResult(result: "Error: missing 'title' or 'status'", isError: true)
            }
            let notes = input["notes"] as? String
            await MemoryService.shared.updateTaskByTitle(title: title, status: status, notes: notes)
            return ToolResult(result: "Updated task '\(title)' to status: \(status)", isError: false)

        case "task_list":
            let status = input["status"] as? String
            let project = input["project"] as? String
            let list = await MemoryService.shared.listTasks(status: status, project: project)
            return ToolResult(result: list, isError: false)

        // ── Memory Shortcut Tools ──

        case "remember":
            guard let fact = input["fact"] as? String else {
                return ToolResult(result: "Error: missing 'fact'", isError: true)
            }
            let category = input["category"] as? String ?? "fact"
            await MemoryService.shared.remember(fact: fact, category: category)
            return ToolResult(result: "Remembered [\(category)]: \(fact)", isError: false)

        case "recall":
            guard let topic = input["topic"] as? String else {
                return ToolResult(result: "Error: missing 'topic'", isError: true)
            }
            let memories = await MemoryService.shared.recall(topic: topic)
            return ToolResult(result: memories, isError: false)

        // ── OpenClaw Communication Tools ──

        case "openclaw_send":
            guard let message = input["message"] as? String else {
                return ToolResult(result: "Error: missing 'message'", isError: true)
            }
            let channel = input["channel"] as? String ?? "telegram"
            let target = input["target"] as? String ?? ""
            do {
                let result = try await OpenClawBridge.shared.sendMessage(
                    channel: channel, target: target, message: message
                )
                return ToolResult(result: "Message sent via \(channel): \(result)", isError: false)
            } catch {
                return ToolResult(result: "Error sending message: \(error.localizedDescription)", isError: true)
            }

        case "openclaw_check":
            let channel = input["channel"] as? String ?? "telegram"
            let target = input["target"] as? String ?? ""
            let limit = input["limit"] as? Int ?? 10
            do {
                let messages = try await OpenClawBridge.shared.readMessages(
                    channel: channel, target: target, limit: limit
                )
                if messages.isEmpty {
                    return ToolResult(result: "No new messages.", isError: false)
                }
                let formatted = messages.map { msg in
                    let sender = msg.sender ?? "unknown"
                    let time = msg.timestamp.map { ISO8601DateFormatter().string(from: $0) } ?? ""
                    return "[\(time)] \(sender): \(msg.text)"
                }.joined(separator: "\n")
                return ToolResult(result: formatted, isError: false)
            } catch {
                return ToolResult(result: "Error reading messages: \(error.localizedDescription)", isError: true)
            }

        default:
            // Check if it's a plugin tool
            if await PluginLoader.shared.isPluginTool(name) {
                do {
                    let pluginResult = try await PluginLoader.shared.executeTool(
                        name: name, input: input
                    )
                    return ToolResult(
                        result: pluginResult.result,
                        isError: pluginResult.isError
                    )
                } catch {
                    return ToolResult(
                        result: "Plugin error: \(error.localizedDescription)",
                        isError: true
                    )
                }
            }
            return ToolResult(result: "Unknown tool: \(name)", isError: true)
        }
    }
}

// MARK: - Tool Result

struct ToolResult {
    let result: String
    let isError: Bool
    var screenshot: ScreenCapture? = nil
}

// MARK: - Tool Call Summary

/// Summary of a single tool call's outcome, used by VerificationEngine
/// to detect tool errors that the screenshot alone cannot reveal.
struct ToolCallSummary: Sendable {
    let toolName: String
    let resultText: String
    let isError: Bool
}

// MARK: - Iteration Result

/// Result of a single agent iteration (one Claude API call + tool execution).
/// Used by the Orchestrator to decide whether to continue, verify, or stop.
struct IterationResult {
    /// Text content from Claude's response (may contain completion token).
    let textContent: String

    /// Whether Claude returned tool calls (wants to continue working).
    let hasMoreWork: Bool

    /// The most recent screenshot from this iteration (for stuck detection + journal).
    let screenshot: ScreenCapture?

    /// API token usage for this iteration.
    let inputTokens: Int
    let outputTokens: Int

    /// Whether the iteration was interrupted by cancellation.
    let cancelled: Bool

    /// Whether any tool calls in this iteration produce visual changes on screen.
    /// False when only non-visual tools (memory, vault, task) were called.
    let hasVisualToolCalls: Bool

    /// Summary of all tool calls executed in this iteration, including error status.
    /// Used by VerificationEngine to penalize scores when tools report errors.
    let toolCallSummaries: [ToolCallSummary]
}
