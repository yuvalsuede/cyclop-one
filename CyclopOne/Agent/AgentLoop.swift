import Foundation
import AppKit

/// The core agent loop: perceive -> reason -> act -> repeat.
///
/// Sprint 2 refactor: Conversation management is now in ConversationManager,
/// tool execution is now in ToolExecutionManager. AgentLoop coordinates both
/// and implements ToolExecutionContext for the tool manager to call back.
///
/// Sprint 3 refactor: the run lifecycle is now split into:
/// - `prepareRun()` -- setup (capture PID, screenshot, first message)
/// - `executeIteration()` -- one Claude API call + tool execution pass
/// - `finishRun()` -- restore panel interaction
///
/// The `Orchestrator` calls these in its supervised loop.
/// The legacy `run()` method still works as a convenience.
///
/// Extensions:
/// - AgentLoop+ToolDispatcher.swift -- ToolExecutionContext protocol, panel/focus, coordinates, API retry
/// - AgentLoop+ConversationBuilder.swift -- prepareRun, system prompt, conversation delegates, resume, testing
actor AgentLoop: ToolExecutionContext {

    let api = ClaudeAPIService.shared
    let captureService = ScreenCaptureService.shared
    let actionExecutor = ActionExecutor.shared
    let accessibilityService = AccessibilityService.shared

    // MARK: - Sprint 2: Extracted Managers

    /// Manages conversation history, pruning, validation, and message injection.
    var conversation: ConversationManager = ConversationManager()

    /// Manages tool dispatch, fingerprinting, repetition detection, and safety gates.
    var toolExec: ToolExecutionManager

    // MARK: - Agent State
    // Note: These are internal (not private) so actor extensions in separate files can access them.

    var config: AgentConfig
    var isCancelled = false
    var latestScreenshot: ScreenCapture?

    /// Completion token for the current run. Generated by the Orchestrator.
    /// Claude must output `<complete>TOKEN</complete>` to signal task completion.
    var completionToken: String?

    /// Sprint 14: Track consecutive API failures for signaling to Orchestrator.
    var consecutiveAPIFailures: Int = 0

    /// Sprint 14: Maximum consecutive API failures before we consider the API unhealthy.
    private let maxConsecutiveAPIFailures: Int = 5

    /// The PID of the app the agent should be interacting with.
    /// Updated when the agent opens a new app or clicks on a window.
    var targetAppPID: pid_t?

    /// Manages panel visibility, click passthrough, and target app activation.
    /// Extracted from AgentLoop to separate UI concerns from agent logic.
    let windowManager = WindowManager()

    /// Weak reference to the panel -- set by coordinator.
    /// Accessed only by capturing into a local variable before MainActor.run blocks.
    weak var panel: NSPanel?

    /// Weak reference to the FloatingDot -- needed to dismiss its popover
    /// and collect all Cyclop One window numbers before screenshots.
    /// Accessed only by capturing into a local variable before MainActor.run blocks.
    weak var floatingDot: FloatingDot?

    /// Expose the current model name for diagnostic logging.
    var currentModelName: String { config.modelName }

    init(config: AgentConfig = AgentConfig()) {
        self.config = config
        let gate = ActionSafetyGate(
            brainModel: config.brainModel,
            permissionMode: config.permissionMode
        )
        self.toolExec = ToolExecutionManager(safetyGate: gate)
    }

    // MARK: - Core Iteration

    /// Execute a single iteration: send conversation to Claude, execute any tool calls.
    /// Called by the Orchestrator in its supervised loop.
    ///
    /// Sprint 14: Includes retry logic with exponential backoff around the Claude API call.
    /// If the API returns 429, respects the retry-after value. Tracks consecutive failures
    /// and propagates the error to the Orchestrator's circuit breaker.
    func executeIteration(
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void,
        onConfirmationNeeded: @Sendable @escaping (String) async -> Bool,
        observer: (any AgentObserver)? = nil
    ) async throws -> IterationResult {
        // M6: Check both cooperative flag AND Task cancellation
        guard !isCancelled && !Task.isCancelled else {
            return IterationResult(
                textContent: "", hasMoreWork: false, screenshot: nil,
                inputTokens: 0, outputTokens: 0, cancelled: true,
                hasVisualToolCalls: false, toolCallSummaries: []
            )
        }

        // Sprint 19: Track iteration count and prune old screenshots from history.
        // Sprint 6: pruneConversationHistory() now also compresses old tool results.
        conversation.iterationCount += 1
        conversation.pruneConversationHistory()

        // Sprint 6: Summarize old messages when payload exceeds ~100KB budget
        conversation.summarizeIfOverBudget()

        // Focus guard: re-activate the target app if another app stole focus.
        // This prevents the agent from sending keystrokes/clicks to the wrong app.
        await ensureTargetAppFocused()

        NSLog("CyclopOne [AgentLoop]: executeIteration -- start, iteration=%d, messageCount=%d, payloadSize=%d bytes",
              conversation.iterationCount, conversation.conversationHistory.count, conversation.conversationPayloadSize())

        onStateChange(.thinking)

        // Build system prompt with skill/memory context and completion protocol
        let systemPrompt = buildIterationSystemPrompt()

        // M6: Bail immediately if cancelled before the expensive API call
        try Task.checkCancellation()

        // Sprint 6: Validate conversation history integrity before sending to API.
        // Pruning can break tool_use/tool_result pairs; this catches and fixes them.
        let historyWasValid = conversation.validateBeforeSend()
        if !historyWasValid {
            NSLog("CyclopOne [AgentLoop]: Conversation history had broken tool pairs -- repaired before API call (iteration=%d)", conversation.iterationCount)
        }

        // Ensure the conversation ends with a user message before sending to Claude.
        // The API returns HTTP 400 if the last message has role "assistant".
        conversation.ensureConversationEndsWithUserMessage()

        // Sprint 14: API call with retry logic
        let response = try await sendAPIWithRetry(
            systemPrompt: systemPrompt,
            onMessage: onMessage
        )

        // M6: Check cancellation after the API call returns
        guard !isCancelled && !Task.isCancelled else {
            return IterationResult(
                textContent: response.textContent,
                hasMoreWork: false,
                screenshot: latestScreenshot,
                inputTokens: response.inputTokens,
                outputTokens: response.outputTokens,
                cancelled: true,
                hasVisualToolCalls: false,
                toolCallSummaries: []
            )
        }

        // API call succeeded: reset consecutive failure counter
        consecutiveAPIFailures = 0

        let assistantMsg = APIMessage.assistant(from: response)
        conversation.appendMessage(assistantMsg)

        let textContent = response.textContent
        if !textContent.isEmpty {
            onMessage(ChatMessage(role: .assistant, content: textContent))
        }

        // If no tool calls, Claude considers itself done
        if !response.hasToolUse {
            NSLog("CyclopOne [AgentLoop]: executeIteration -- end (no tool calls), iteration=%d, textLen=%d, tokens=%d/%d",
                  conversation.iterationCount, textContent.count, response.inputTokens, response.outputTokens)
            return IterationResult(
                textContent: textContent,
                hasMoreWork: false,
                screenshot: latestScreenshot,
                inputTokens: response.inputTokens,
                outputTokens: response.outputTokens,
                cancelled: false,
                hasVisualToolCalls: false,
                toolCallSummaries: []
            )
        }

        // -- Execute tool calls --
        var lastScreenshot: ScreenCapture? = nil
        var hasVisualToolCalls = false
        var toolCallSummaries: [ToolCallSummary] = []
        for toolUse in response.toolUses {
            // M6: Check BOTH cooperative flag and Task cancellation before each tool
            if isCancelled || Task.isCancelled {
                return IterationResult(
                    textContent: textContent,
                    hasMoreWork: false,
                    screenshot: latestScreenshot,
                    inputTokens: response.inputTokens,
                    outputTokens: response.outputTokens,
                    cancelled: true,
                    hasVisualToolCalls: hasVisualToolCalls,
                    toolCallSummaries: toolCallSummaries
                )
            }

            // Track whether this tool produces visual changes
            if !ToolExecutionManager.nonVisualTools.contains(toolUse.name) {
                hasVisualToolCalls = true
            }

            let toolResult = await toolExec.executeToolCall(
                name: toolUse.name,
                input: toolUse.input,
                context: self,
                iterationCount: conversation.iterationCount,
                currentStepInstruction: conversation.currentStepInstruction,
                confirmDestructiveActions: config.confirmDestructiveActions,
                onStateChange: onStateChange,
                onMessage: onMessage,
                onConfirmationNeeded: onConfirmationNeeded
            )

            // M3: Notify observer of tool execution (fire-and-forget with 5s timeout
            // to prevent slow Telegram I/O from blocking the agent iteration loop)
            if let obs = observer {
                let toolName = toolUse.name
                let summary = toolResult.result
                let isError = toolResult.isError
                let screenshotData = (!ToolExecutionManager.nonVisualTools.contains(toolName))
                    ? toolResult.screenshot?.imageData : nil

                Task {
                    await ToolExecutionManager.fireAndForgetObserver(timeout: 5.0) {
                        await obs.onToolExecution(
                            toolName: toolName,
                            summary: summary,
                            isError: isError
                        )
                    }
                    if let ssData = screenshotData {
                        await ToolExecutionManager.fireAndForgetObserver(timeout: 5.0) {
                            await obs.onScreenshot(
                                imageData: ssData,
                                context: "After \(toolName)"
                            )
                        }
                    }
                }
            }

            // Surface tool errors to the UI so the user can see what went wrong
            if toolResult.isError {
                onMessage(ChatMessage(role: .system, content: "Tool error (\(toolUse.name)): \(toolResult.result)"))
            }

            // Collect tool call summary for verification
            toolCallSummaries.append(ToolCallSummary(
                toolName: toolUse.name,
                resultText: String(toolResult.result.prefix(500)),
                isError: toolResult.isError
            ))

            if let ss = toolResult.screenshot {
                lastScreenshot = ss
            }

            // M5: Track recent tool calls for safety gate context
            toolExec.trackToolCall(name: toolUse.name, summary: String(toolResult.result.prefix(200)))

            // Track tool call fingerprint for repetition detection.
            // Fingerprint = tool name + sorted serialized input parameters.
            let fingerprint = toolExec.buildToolCallFingerprint(name: toolUse.name, input: toolUse.input)
            toolExec.trackToolCallFingerprint(fingerprint)

            let resultMsg = APIMessage.toolResult(
                toolUseId: toolUse.id,
                result: toolResult.result,
                isError: toolResult.isError,
                screenshot: toolResult.screenshot
            )
            conversation.appendMessage(resultMsg)
        }

        // Repetition detection: if the last N tool calls have identical fingerprints,
        // inject a warning message into the conversation to break the loop.
        if toolExec.detectToolCallRepetition() {
            let warningText = """
            WARNING: You are repeating the same action with identical parameters. \
            This will not produce a different result. You MUST try a completely different \
            approach or declare the task complete with <task_complete/>. \
            If you cannot find another way to accomplish the task, output <task_complete/> \
            with an explanation of what went wrong.
            """
            let warningMsg = APIMessage.userText(warningText)
            conversation.appendMessage(warningMsg)
            onMessage(ChatMessage(role: .system, content: "Repetition detected -- injecting warning to break loop."))
            NSLog("CyclopOne [AgentLoop]: Repetition warning injected at iteration %d", conversation.iterationCount)
        }

        // Brief pause between iterations
        try? await Task.sleep(nanoseconds: 100_000_000)

        NSLog("CyclopOne [AgentLoop]: executeIteration -- end (tool calls executed), iteration=%d, toolCount=%d, hasVisualTools=%d, hasScreenshot=%d, tokens=%d/%d",
              conversation.iterationCount, response.toolUses.count, hasVisualToolCalls ? 1 : 0, lastScreenshot != nil ? 1 : 0,
              response.inputTokens, response.outputTokens)

        return IterationResult(
            textContent: textContent,
            hasMoreWork: true,  // Had tool calls -> more work likely
            screenshot: lastScreenshot ?? latestScreenshot,
            inputTokens: response.inputTokens,
            outputTokens: response.outputTokens,
            cancelled: false,
            hasVisualToolCalls: hasVisualToolCalls,
            toolCallSummaries: toolCallSummaries
        )
    }

    /// Sprint 14: Number of consecutive API failures. Used by the Orchestrator
    /// to monitor agent health.
    var apiFailureCount: Int { consecutiveAPIFailures }

    /// Sprint 7: Get the complete tool call history for the current run.
    /// Used by the Orchestrator to record procedural memory after successful runs.
    func getRunToolCallHistory() -> [(name: String, summary: String)] {
        return toolExec.runToolCallHistory
    }
}

// MARK: - Tool Result

struct ToolResult {
    let result: String
    let isError: Bool
    var screenshot: ScreenCapture? = nil
}

// MARK: - Tool Call Summary

/// Summary of a single tool call's outcome, used by VerificationEngine
/// to detect tool errors that the screenshot alone cannot reveal.
struct ToolCallSummary: Sendable {
    let toolName: String
    let resultText: String
    let isError: Bool
}

// MARK: - Iteration Result

/// Result of a single agent iteration (one Claude API call + tool execution).
/// Used by the Orchestrator to decide whether to continue, verify, or stop.
struct IterationResult {
    /// Text content from Claude's response (may contain completion token).
    let textContent: String

    /// Whether Claude returned tool calls (wants to continue working).
    let hasMoreWork: Bool

    /// The most recent screenshot from this iteration (for stuck detection + journal).
    let screenshot: ScreenCapture?

    /// API token usage for this iteration.
    let inputTokens: Int
    let outputTokens: Int

    /// Whether the iteration was interrupted by cancellation.
    let cancelled: Bool

    /// Whether any tool calls in this iteration produce visual changes on screen.
    /// False when only non-visual tools (memory, vault, task) were called.
    let hasVisualToolCalls: Bool

    /// Summary of all tool calls executed in this iteration, including error status.
    /// Used by VerificationEngine to penalize scores when tools report errors.
    let toolCallSummaries: [ToolCallSummary]
}
