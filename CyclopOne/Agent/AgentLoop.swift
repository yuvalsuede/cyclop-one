import Foundation
import AppKit

/// The core agent loop: perceive → reason → act → repeat.
///
/// Sprint 3 refactor: the run lifecycle is now split into:
/// - `prepareRun()` — setup (capture PID, screenshot, first message)
/// - `executeIteration()` — one Claude API call + tool execution pass
/// - `finishRun()` — restore panel interaction
///
/// The `Orchestrator` calls these in its supervised loop.
/// The legacy `run()` method still works as a convenience.
actor AgentLoop {

    /// Tools that do not produce visual changes on screen.
    /// Used to determine whether verification scoring should be skipped.
    private static let nonVisualTools: Set<String> = [
        "remember", "recall",
        "vault_read", "vault_write", "vault_search", "vault_list", "vault_append",
        "task_create", "task_update", "task_list", "task_complete",
        "shell_exec", "run_shell_command"
    ]

    private let api = ClaudeAPIService.shared
    private let capture = ScreenCaptureService.shared
    private let executor = ActionExecutor.shared
    private let accessibility = AccessibilityService.shared

    private var config: AgentConfig
    private var isCancelled = false
    private var conversationHistory: [[String: Any]] = []
    private var latestScreenshot: ScreenCapture?

    /// Completion token for the current run. Generated by the Orchestrator.
    /// Claude must output `<complete>TOKEN</complete>` to signal task completion.
    private var completionToken: String?

    /// Sprint 18: Skill context injected by the Orchestrator when skills match.
    /// Appended to the system prompt for the current run.
    private var skillContext: String = ""

    /// Memory context injected by the Orchestrator from MemoryService.
    /// Included in the system prompt for persistent memory across runs.
    private var memoryContext: String = ""

    /// Sprint 19: Current iteration count for conversation pruning.
    private var iterationCount: Int = 0

    /// Number of most-recent screenshots to keep in conversation history.
    /// Only the latest screenshot is kept; older ones are replaced with "[screenshot removed]".
    private let screenshotPruneThreshold: Int = 1

    /// Maximum number of messages in conversation history before oldest are evicted.
    /// Prevents unbounded memory growth. The first 2 messages (initial user prompt +
    /// first assistant response) are always kept for task context.
    /// 20 messages ≈ 10 turns (assistant+tool_result pairs), enough for multi-step tasks.
    private let maxConversationMessages: Int = 20

    /// Sprint 14: Track consecutive API failures for signaling to Orchestrator.
    private var consecutiveAPIFailures: Int = 0

    /// Sprint 14: Maximum consecutive API failures before we consider the API unhealthy.
    private let maxConsecutiveAPIFailures: Int = 5

    /// The PID of the app the agent should be interacting with.
    /// Updated when the agent opens a new app or clicks on a window.
    private var targetAppPID: pid_t?

    /// Weak reference to the panel — set by coordinator.
    /// Accessed only by capturing into a local variable before MainActor.run blocks.
    private weak var panel: NSPanel?

    /// Weak reference to the FloatingDot — needed to dismiss its popover
    /// and collect all Cyclop One window numbers before screenshots.
    /// Accessed only by capturing into a local variable before MainActor.run blocks.
    private weak var floatingDot: FloatingDot?

    /// Expose the current model name for diagnostic logging.
    var currentModelName: String { config.modelName }

    init(config: AgentConfig = AgentConfig()) {
        self.config = config
    }

    func setPanel(_ panel: NSPanel) {
        self.panel = panel
    }

    func setFloatingDot(_ dot: FloatingDot) {
        self.floatingDot = dot
        self.panel = dot  // FloatingDot IS the NSPanel
    }

    // MARK: - Panel & Focus Control

    /// Fully hide all Cyclop One windows (for screenshots only).
    ///
    /// 1. Dismiss the popover (which is a separate NSWindow created by NSPopover).
    /// 2. Collect all Cyclop One window numbers and update ScreenCaptureService exclusion list.
    /// 3. Hide the floating dot panel.
    /// 4. Sleep 300ms for the window server to process the hide.
    /// 5. Wait/poll until all Cyclop One windows are gone from the on-screen window list.
    /// 6. Verify and log that no Cyclop One windows remain.
    private func hideForScreenshot() async {
        // Step 1: Dismiss popover and collect all window IDs BEFORE hiding
        let windowNumbers = await MainActor.run { [floatingDot] () -> [Int] in
            // Close the popover first (it creates its own window)
            floatingDot?.dismissPopover()
            // Collect window numbers (dot panel + any remaining popover window)
            return floatingDot?.allWindowNumbers() ?? []
        }

        // Step 2: Update excluded window IDs in ScreenCaptureService for the SCKit path
        let excludedIDs = Set(windowNumbers.map { CGWindowID($0) })
        await capture.setExcludedWindowIDs(excludedIDs)

        // Step 3: Hide the floating dot panel
        await MainActor.run { [panel] in
            panel?.orderOut(nil)
        }

        // Step 4: Brief delay for the window server to process the hide
        try? await Task.sleep(nanoseconds: 150_000_000)

        // Step 5: Poll until all Cyclop One windows are gone (up to 200ms)
        await waitForWindowsHidden(windowNumbers: windowNumbers, timeout: 200_000_000)

        // Step 6: Verify no Cyclop One windows remain and log diagnostics.
        // Only check windows at normal layer (0) that we tried to hide.
        // Status bar items (layer 25), floating windows, and other system-level
        // windows are excluded from captures by PID filtering, not by hiding.
        let ourPID = ProcessInfo.processInfo.processIdentifier
        let windowList = CGWindowListCopyWindowInfo(.optionOnScreenOnly, kCGNullWindowID) as? [[String: Any]] ?? []
        let knownWindowSet = Set(windowNumbers)
        let ourVisibleWindows = windowList.filter { info in
            guard let pid = info[kCGWindowOwnerPID as String] as? Int32, pid == ourPID else { return false }
            guard let num = info[kCGWindowNumber as String] as? Int else { return false }
            // Only warn about windows we explicitly tried to hide (the dot panel + popover)
            // Other Cyclop One windows (status bar, auxiliary) are excluded by PID in the capture pipeline
            return knownWindowSet.contains(num)
        }
        if ourVisibleWindows.isEmpty {
            NSLog("CyclopOne [hideForScreenshot]: Verified — tracked Cyclop One windows hidden (PID %d). Safe to capture.", ourPID)
        } else {
            let windowNums = ourVisibleWindows.compactMap { $0[kCGWindowNumber as String] as? Int }
            NSLog("CyclopOne [hideForScreenshot]: WARNING — %d tracked Cyclop One windows still visible (PID %d): %@",
                  ourVisibleWindows.count, ourPID, windowNums.map { String($0) }.joined(separator: ", "))
        }
    }

    /// Poll until none of the given window numbers are visible in the on-screen window list, or timeout.
    private func waitForWindowsHidden(windowNumbers: [Int], timeout: UInt64) async {
        guard !windowNumbers.isEmpty else { return }
        let windowSet = Set(windowNumbers)

        let deadline = DispatchTime.now().uptimeNanoseconds + timeout
        while DispatchTime.now().uptimeNanoseconds < deadline {
            let windowList = CGWindowListCopyWindowInfo(.optionOnScreenOnly, kCGNullWindowID) as? [[String: Any]] ?? []
            let anyStillVisible = windowList.contains { info in
                guard let num = info[kCGWindowNumber as String] as? Int else { return false }
                return windowSet.contains(num)
            }
            if !anyStillVisible { return }
            try? await Task.sleep(nanoseconds: 20_000_000) // 20ms poll interval
        }
    }

    /// Bring panel back after screenshot — but DON'T steal keyboard focus.
    private func showAfterScreenshot() async {
        await MainActor.run { [panel] in
            panel?.orderFront(nil)
        }
    }

    /// Make panel transparent to mouse events (for clicks/drags/scrolls).
    /// Panel stays visible — no flicker.
    private func letClicksThrough() async {
        await MainActor.run { [panel] in
            panel?.ignoresMouseEvents = true
        }
        try? await Task.sleep(nanoseconds: 50_000_000) // 50ms
    }

    /// Restore panel mouse event handling.
    private func stopClicksThrough() async {
        await MainActor.run { [panel] in
            panel?.ignoresMouseEvents = false
        }
    }

    /// Ensure the target application (not Cyclop One) has keyboard focus.
    /// Sprint 7: Uses NSRunningApplication.activate(options: .activateIgnoringOtherApps)
    /// for reliable AX-based activation, plus verification polling.
    private func activateTargetApp() async {
        let savedPID = self.targetAppPID
        await MainActor.run { [panel] in
            let currentPID = ProcessInfo.processInfo.processIdentifier

            // Make sure our panel can't become key
            panel?.ignoresMouseEvents = true

            // Deactivate our entire app
            NSApp.deactivate()

            // Try to activate the saved target app with activateIgnoringOtherApps
            if let pid = savedPID,
               let app = NSRunningApplication(processIdentifier: pid),
               !app.isTerminated {
                app.activate(options: .activateIgnoringOtherApps)
                return
            }

            // Fallback: activate the frontmost non-Cyclop One app
            if let front = NSWorkspace.shared.frontmostApplication,
               front.processIdentifier != currentPID {
                front.activate(options: .activateIgnoringOtherApps)
                return
            }

            // Last resort: find any regular app
            if let target = NSWorkspace.shared.runningApplications.first(where: {
                $0.activationPolicy == .regular &&
                $0.processIdentifier != currentPID &&
                !$0.isTerminated &&
                !$0.isHidden
            }) {
                target.activate(options: .activateIgnoringOtherApps)
            }
        }

        // Sprint 7: Poll to verify activation succeeded (up to 500ms)
        await verifyActivation(expectedPID: savedPID, timeout: 500_000_000)
    }

    /// Poll frontmostApplication every 50ms to confirm the target app is active.
    private func verifyActivation(expectedPID: pid_t?, timeout: UInt64) async {
        let currentPID = ProcessInfo.processInfo.processIdentifier
        let deadline = DispatchTime.now().uptimeNanoseconds + timeout

        while DispatchTime.now().uptimeNanoseconds < deadline {
            let frontPID = await MainActor.run {
                NSWorkspace.shared.frontmostApplication?.processIdentifier
            }

            // Success: something other than Cyclop One is frontmost
            if let front = frontPID, front != currentPID {
                // If we had a specific target, verify it matches
                if let expected = expectedPID, front == expected {
                    return // Target app is frontmost
                }
                // No specific target, any non-self app is fine
                if expectedPID == nil {
                    return
                }
            }
            try? await Task.sleep(nanoseconds: 50_000_000) // 50ms
        }
        // Timeout — log warning but continue (best effort)
    }

    /// Re-enable the panel for user interaction (called when agent finishes).
    private func restorePanelInteraction() async {
        await MainActor.run { [panel] in
            panel?.ignoresMouseEvents = false
            panel?.orderFront(nil)
        }
    }

    // MARK: - Orchestrated Run Interface

    /// Prepare a new run: capture target PID, take initial screenshot, build first message.
    /// Called by the Orchestrator at the start of each run.
    /// Returns the initial screenshot (or nil if capture failed).
    func prepareRun(
        userMessage: String,
        completionToken: String,
        targetPID suppliedPID: pid_t? = nil,
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void
    ) async -> ScreenCapture? {
        NSLog("CyclopOne [AgentLoop]: prepareRun — start, completionToken=%@, model=%@, suppliedPID=%@",
              String(completionToken.prefix(8)), config.modelName,
              suppliedPID.map { String($0) } ?? "nil")

        isCancelled = false
        conversationHistory.removeAll()
        latestScreenshot = nil
        self.completionToken = completionToken
        consecutiveAPIFailures = 0
        iterationCount = 0

        // ── Determine the target app ──
        // If a PID was supplied (captured when the popover opened), use it.
        // Otherwise fall back to detecting the current frontmost app.
        if let pid = suppliedPID {
            targetAppPID = pid
            NSLog("CyclopOne [prepareRun]: Using supplied target PID %d", pid)

            // Bring the target app AND its windows to the front.
            // NSRunningApplication.activate() alone only activates the menu bar —
            // it doesn't raise windows. We use AppleScript as the most reliable
            // way to bring an app's windows to the front on macOS.
            let appName = await MainActor.run { () -> String? in
                NSRunningApplication(processIdentifier: pid)?.localizedName
            }
            if let name = appName {
                // Sanitize app name to prevent AppleScript injection:
                // escape backslashes first, then double quotes.
                let sanitized = name
                    .replacingOccurrences(of: "\\", with: "\\\\")
                    .replacingOccurrences(of: "\"", with: "\\\"")
                let script = "tell application \"\(sanitized)\" to activate"
                if let appleScript = NSAppleScript(source: script) {
                    var errorInfo: NSDictionary?
                    appleScript.executeAndReturnError(&errorInfo)
                    if let err = errorInfo {
                        NSLog("CyclopOne [prepareRun]: AppleScript activate failed: %@", err)
                    } else {
                        NSLog("CyclopOne [prepareRun]: AppleScript activated '%@' (PID %d)", name, pid)
                    }
                }
            }
            // Give the app time to bring its windows to the front and render
            try? await Task.sleep(nanoseconds: 300_000_000) // 300ms
        } else {
            targetAppPID = await MainActor.run { () -> pid_t? in
                let currentPID = ProcessInfo.processInfo.processIdentifier
                if let front = NSWorkspace.shared.frontmostApplication,
                   front.processIdentifier != currentPID {
                    return front.processIdentifier
                }
                return NSWorkspace.shared.runningApplications.first(where: {
                    $0.activationPolicy == .regular &&
                    $0.processIdentifier != currentPID &&
                    !$0.isTerminated
                })?.processIdentifier
            }
        }

        // ── Capture screenshot (hide panel so it's not in the image) ──
        await hideForScreenshot()
        onStateChange(.capturing)

        let screenshot: ScreenCapture?
        do {
            screenshot = try await capture.captureScreen(
                maxDimension: config.screenshotMaxDimension,
                quality: config.screenshotJPEGQuality
            )
            latestScreenshot = screenshot
        } catch {
            screenshot = nil
            onMessage(ChatMessage(role: .system, content: "⚠️ Screen capture failed: \(error.localizedDescription)"))
        }

        await showAfterScreenshot()

        // Read the UI tree for the TARGET app (not Cyclop One, which may now be frontmost)
        let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)

        // ── Debug: log what Claude will receive and save diagnostic copy ──
        if let ss = screenshot {
            NSLog("CyclopOne [prepareRun]: Screenshot for Claude — %dx%d px, mediaType=%@, base64 length=%d chars, data=%d bytes, screen frame=%.0fx%.0f pts",
                  ss.width, ss.height, ss.mediaType,
                  ss.base64.count, ss.imageData.count,
                  ss.screenFrame.width, ss.screenFrame.height)
            // Save diagnostic copy so we can verify exactly what Claude receives
            let ext = ss.mediaType == "image/png" ? "png" : "jpg"
            let diagPath = "/tmp/cyclopone_last_sent.\(ext)"
            try? ss.imageData.write(to: URL(fileURLWithPath: diagPath))
            NSLog("CyclopOne [prepareRun]: Diagnostic screenshot saved to %@", diagPath)
        } else {
            NSLog("CyclopOne [prepareRun]: No screenshot available for Claude")
        }

        // ── Build initial user message ──
        var enhancedMessage = userMessage
        if let ss = screenshot {
            enhancedMessage += "\n\n[Screenshot: \(ss.width)x\(ss.height)px. Actual screen: \(ss.screenWidth)x\(ss.screenHeight) points. Provide coordinates in screenshot pixel space — auto-mapped to screen.]"
        } else {
            enhancedMessage += "\n\n[No screenshot available — screen capture was blocked or failed. You can still help with this request using conversation, shell commands, AppleScript, and open_application. Use take_screenshot later if you need visual context.]"
        }

        let userMsg = ClaudeAPIService.buildUserMessage(
            text: enhancedMessage,
            screenshot: screenshot,
            uiTreeSummary: uiTree
        )
        conversationHistory.append(userMsg)

        NSLog("CyclopOne [AgentLoop]: prepareRun — end, messageCount=%d, hasScreenshot=%d",
              conversationHistory.count, screenshot != nil ? 1 : 0)

        return screenshot
    }

    /// Execute a single iteration: send conversation to Claude, execute any tool calls.
    /// Called by the Orchestrator in its supervised loop.
    ///
    /// Sprint 14: Includes retry logic with exponential backoff around the Claude API call.
    /// If the API returns 429, respects the retry-after value. Tracks consecutive failures
    /// and propagates the error to the Orchestrator's circuit breaker.
    func executeIteration(
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void,
        onConfirmationNeeded: @Sendable @escaping (String) async -> Bool
    ) async throws -> IterationResult {
        guard !isCancelled else {
            return IterationResult(
                textContent: "", hasMoreWork: false, screenshot: nil,
                inputTokens: 0, outputTokens: 0, cancelled: true,
                hasVisualToolCalls: false
            )
        }

        // Sprint 19: Track iteration count and prune old screenshots from history
        iterationCount += 1
        pruneConversationHistory()

        // Focus guard: re-activate the target app if another app stole focus.
        // This prevents the agent from sending keystrokes/clicks to the wrong app.
        await ensureTargetAppFocused()

        NSLog("CyclopOne [AgentLoop]: executeIteration — start, iteration=%d, messageCount=%d, payloadSize=%d bytes",
              iterationCount, conversationHistory.count, conversationPayloadSize())

        onStateChange(.thinking)

        // Build system prompt, appending skill context, memory context, and completion protocol if set.
        // SECURITY: The actual completion token is NOT embedded in the prompt to prevent
        // prompt injection attacks. Claude outputs a canonical marker; the Orchestrator
        // validates it independently using the secret token.
        var systemPrompt = ToolDefinitions.buildSystemPrompt(memoryContext: memoryContext, skillContext: skillContext)
        if let token = completionToken, !token.isEmpty {
            systemPrompt += """


            ## Completion Protocol
            When you have completed the user's task, output exactly: <task_complete/>

            Guidelines for when to declare completion:
            - If the task was to open an app: it's open and visible → complete.
            - If the task was to type text: the text is visible on screen → complete.
            - If the task was to click something: you clicked it and saw the result → complete.
            - If the task was to navigate to a URL: the page loaded → complete.
            - If the task was to send a message: you typed it and pressed Enter/Send → complete.
            - For multi-step tasks: complete each step, then declare done after the LAST step.

            Do NOT keep iterating after the core action is done. If you already performed the \
            requested action and can see the expected result on screen, output <task_complete/> immediately.
            Do NOT output <task_complete/> before actually performing the action.
            """
        }

        // Sprint 14: API call with retry logic
        let response = try await sendAPIWithRetry(
            systemPrompt: systemPrompt,
            onMessage: onMessage
        )

        // API call succeeded: reset consecutive failure counter
        consecutiveAPIFailures = 0

        let assistantMsg = ClaudeAPIService.buildAssistantMessage(from: response)
        conversationHistory.append(assistantMsg)

        let textContent = response.textContent
        if !textContent.isEmpty {
            onMessage(ChatMessage(role: .assistant, content: textContent))
        }

        // If no tool calls, Claude considers itself done
        if !response.hasToolUse {
            NSLog("CyclopOne [AgentLoop]: executeIteration — end (no tool calls), iteration=%d, textLen=%d, tokens=%d/%d",
                  iterationCount, textContent.count, response.inputTokens, response.outputTokens)
            return IterationResult(
                textContent: textContent,
                hasMoreWork: false,
                screenshot: latestScreenshot,
                inputTokens: response.inputTokens,
                outputTokens: response.outputTokens,
                cancelled: false,
                hasVisualToolCalls: false
            )
        }

        // -- Execute tool calls --
        var lastScreenshot: ScreenCapture? = nil
        var hasVisualToolCalls = false
        for toolUse in response.toolUses {
            if isCancelled {
                return IterationResult(
                    textContent: textContent,
                    hasMoreWork: false,
                    screenshot: latestScreenshot,
                    inputTokens: response.inputTokens,
                    outputTokens: response.outputTokens,
                    cancelled: true,
                    hasVisualToolCalls: hasVisualToolCalls
                )
            }

            // Track whether this tool produces visual changes
            if !Self.nonVisualTools.contains(toolUse.name) {
                hasVisualToolCalls = true
            }

            let toolResult = await executeToolCall(
                name: toolUse.name,
                input: toolUse.input,
                onStateChange: onStateChange,
                onMessage: onMessage,
                onConfirmationNeeded: onConfirmationNeeded
            )

            if let ss = toolResult.screenshot {
                lastScreenshot = ss
            }

            let resultMsg = ClaudeAPIService.buildToolResultMessage(
                toolUseId: toolUse.id,
                result: toolResult.result,
                isError: toolResult.isError,
                screenshot: toolResult.screenshot
            )
            conversationHistory.append(resultMsg)
        }

        // Brief pause between iterations
        try? await Task.sleep(nanoseconds: 100_000_000)

        NSLog("CyclopOne [AgentLoop]: executeIteration — end (tool calls executed), iteration=%d, toolCount=%d, hasVisualTools=%d, hasScreenshot=%d, tokens=%d/%d",
              iterationCount, response.toolUses.count, hasVisualToolCalls ? 1 : 0, lastScreenshot != nil ? 1 : 0,
              response.inputTokens, response.outputTokens)

        return IterationResult(
            textContent: textContent,
            hasMoreWork: true,  // Had tool calls -> more work likely
            screenshot: lastScreenshot ?? latestScreenshot,
            inputTokens: response.inputTokens,
            outputTokens: response.outputTokens,
            cancelled: false,
            hasVisualToolCalls: hasVisualToolCalls
        )
    }

    // MARK: - Tool Array (includes plugins)

    /// Build the combined tool array from built-in tools + loaded plugin tools.
    private static func buildToolArray() async -> [[String: Any]] {
        var tools = ToolDefinitions.tools
        let pluginTools = await PluginLoader.shared.toolDefinitions()
        tools.append(contentsOf: pluginTools)
        return tools
    }

    // MARK: - API Retry (Sprint 14)

    /// Send a message to the Claude API with retry logic and error classification.
    ///
    /// - Classifies errors as transient, rate-limited, or permanent.
    /// - For 429 responses, attempts to parse the retry-after value.
    /// - Uses exponential backoff for transient errors.
    /// - Tracks consecutive failures for health monitoring.
    private func sendAPIWithRetry(
        systemPrompt: String,
        onMessage: @Sendable @escaping (ChatMessage) -> Void
    ) async throws -> ClaudeResponse {
        let maxRetryAttempts = 3
        var lastError: Error?

        for attempt in 0..<maxRetryAttempts {
            do {
                NSLog("CyclopOne [AgentLoop]: Calling Claude API (model=%@, messages=%d, attempt=%d/%d)",
                      config.modelName, conversationHistory.count, attempt + 1, maxRetryAttempts)
                let response = try await api.sendMessage(
                    messages: conversationHistory,
                    systemPrompt: systemPrompt,
                    tools: await Self.buildToolArray(),
                    model: config.modelName
                )
                NSLog("CyclopOne [AgentLoop]: API success — %d content blocks, stopReason=%@, tokens=%d/%d",
                      response.contentBlocks.count, response.stopReason, response.inputTokens, response.outputTokens)
                return response
            } catch {
                NSLog("CyclopOne [AgentLoop]: API error (attempt %d): %@", attempt + 1, error.localizedDescription)
                lastError = error
                consecutiveAPIFailures += 1
                let classification = classifyError(error)

                switch classification {
                case .permanent:
                    // Don't retry permanent errors
                    throw error

                case .rateLimit(let retryAfter):
                    let delay = retryAfter ?? (5.0 * pow(2.0, Double(attempt)))
                    if attempt < maxRetryAttempts - 1 {
                        onMessage(ChatMessage(
                            role: .system,
                            content: "Rate limited. Retrying in \(Int(delay))s (attempt \(attempt + 2)/\(maxRetryAttempts))..."
                        ))
                        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                        continue
                    }

                case .transient:
                    let delay = 2.0 * pow(2.0, Double(attempt))  // 2s, 4s, 8s
                    if attempt < maxRetryAttempts - 1 {
                        onMessage(ChatMessage(
                            role: .system,
                            content: "API error (transient). Retrying in \(Int(delay))s (attempt \(attempt + 2)/\(maxRetryAttempts))..."
                        ))
                        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                        continue
                    }

                case .unknown:
                    let delay = 3.0 * pow(2.0, Double(attempt))  // 3s, 6s, 12s
                    if attempt < maxRetryAttempts - 1 {
                        try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
                        continue
                    }
                }
            }
        }

        throw lastError ?? APIError.invalidResponse
    }

    /// Sprint 14: Number of consecutive API failures. Used by the Orchestrator
    /// to monitor agent health.
    var apiFailureCount: Int { consecutiveAPIFailures }

    /// Restore panel interaction after a run completes.
    /// Called by the Orchestrator (or legacy run()) when the run is done.
    func finishRun() async {
        completionToken = nil
        await restorePanelInteraction()
    }

    // MARK: - Legacy Run (backward-compatible convenience)

    /// Run the full agent loop. This is the legacy entry point used before
    /// the Orchestrator was introduced. It calls prepareRun + executeIteration
    /// in a simple loop without journal/verification/stuck detection.
    func run(
        userMessage: String,
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void,
        onConfirmationNeeded: @Sendable @escaping (String) async -> Bool
    ) async {
        var iteration = 0

        // CONC-M5: Ensure panel interaction is always restored, even on error/throw.
        defer {
            Task { [weak self] in
                await self?.finishRun()
            }
        }

        _ = await prepareRun(
            userMessage: userMessage,
            completionToken: "",  // No completion token for legacy path
            onStateChange: onStateChange,
            onMessage: onMessage
        )

        while iteration < config.maxIterations && !isCancelled {
            iteration += 1

            do {
                let result = try await executeIteration(
                    onStateChange: onStateChange,
                    onMessage: onMessage,
                    onConfirmationNeeded: onConfirmationNeeded
                )

                if result.cancelled {
                    onMessage(ChatMessage(role: .system, content: "⛔ Cancelled."))
                    onStateChange(.idle)
                    return
                }

                if !result.hasMoreWork {
                    break
                }
            } catch {
                onMessage(ChatMessage(role: .system, content: "❌ API Error: \(error.localizedDescription)"))
                onStateChange(.error(error.localizedDescription))
                return
            }
        }

        if iteration >= config.maxIterations {
            onMessage(ChatMessage(role: .system, content: "⚠️ Max iterations (\(config.maxIterations)) reached."))
        }
        onStateChange(.done)
    }

    func cancel() {
        isCancelled = true
    }

    func clearHistory() {
        conversationHistory.removeAll()
        latestScreenshot = nil
        completionToken = nil
        consecutiveAPIFailures = 0
        iterationCount = 0
        skillContext = ""
        memoryContext = ""
    }

    // MARK: - Conversation History Pruning (Sprint 19)

    /// Returns the current number of messages in the conversation history.
    /// Exposed for testing via @testable import.
    func getConversationHistoryCount() -> Int {
        return conversationHistory.count
    }

    /// Returns the current iteration count. Exposed for testing.
    func getIterationCount() -> Int {
        return iterationCount
    }

    /// Set the iteration count directly. Exposed for testing via @testable import.
    func setIterationCountForTesting(_ count: Int) {
        iterationCount = count
    }

    /// Inject a verification rejection message into the conversation history.
    /// Used by the Orchestrator when the Babysitter exit lock rejects a completion.
    /// Adds the message as a user-role message so Claude sees the feedback on the next iteration.
    func injectVerificationFeedback(_ feedback: String) {
        let message: [String: Any] = [
            "role": "user",
            "content": [
                ["type": "text", "text": feedback] as [String: Any]
            ] as [[String: Any]]
        ]
        conversationHistory.append(message)
    }

    /// Append a raw message to conversation history. Exposed for testing via @testable import.
    func appendMessageForTesting(_ message: [String: Any]) {
        conversationHistory.append(message)
    }

    /// Get a conversation history message at the given index. Exposed for testing.
    func getMessageForTesting(at index: Int) -> [String: Any]? {
        guard index >= 0, index < conversationHistory.count else { return nil }
        return conversationHistory[index]
    }

    /// Prune old screenshot base64 data from conversation history to reduce API payload size.
    ///
    /// After `screenshotPruneThreshold` iterations, replaces base64 image data in messages
    /// older than the threshold with a placeholder text. This prevents conversation payloads
    /// from growing unboundedly with large base64 strings (~200KB+ each).
    ///
    /// Only the most recent `screenshotPruneThreshold` messages with screenshots are kept intact.
    /// Older screenshots are replaced with `[screenshot removed]`.
    func pruneConversationHistory() {
        // Enforce max conversation message count to prevent unbounded growth.
        // Keep the first message (initial user prompt) and the most recent messages.
        //
        // CRITICAL: After removing messages, we must also remove any orphaned
        // tool_result blocks whose tool_use_id no longer matches a tool_use in
        // the remaining history. The Claude API rejects orphaned tool_results.
        if conversationHistory.count > maxConversationMessages {
            let excess = conversationHistory.count - maxConversationMessages
            // Preserve first 2 messages (initial user prompt + first assistant response)
            let preserveCount = min(2, conversationHistory.count)
            let maxRemovable = max(0, conversationHistory.count - preserveCount - 1)
            let toRemove = min(excess, maxRemovable)
            if toRemove > 0 {
                conversationHistory.removeSubrange(preserveCount..<(preserveCount + toRemove))
                NSLog("CyclopOne [AgentLoop]: Evicted %d oldest messages, history now %d messages",
                      toRemove, conversationHistory.count)
            }
        }

        // Always clean up orphaned tool_result blocks — not just after eviction.
        // Orphans can arise from API errors, partial responses, or other edge cases.
        removeOrphanedToolResults()

        // Always prune — even early iterations benefit from smaller payloads

        // Find all message indices that contain image content blocks
        var imageMessageIndices: [Int] = []
        for (index, message) in conversationHistory.enumerated() {
            if messageContainsImage(message) {
                imageMessageIndices.append(index)
            }
        }

        // Keep the most recent screenshotPruneThreshold images, prune the rest
        let countToPreserve = screenshotPruneThreshold
        guard imageMessageIndices.count > countToPreserve else { return }

        let indicesToPrune = imageMessageIndices.dropLast(countToPreserve)
        var prunedBytes = 0

        for index in indicesToPrune {
            let (pruned, bytesRemoved) = pruneImageFromMessage(conversationHistory[index])
            conversationHistory[index] = pruned
            prunedBytes += bytesRemoved
        }

        if prunedBytes > 0 {
            let prunedKB = prunedBytes / 1024
            print("[AgentLoop] Pruned \(indicesToPrune.count) old screenshots from conversation history (~\(prunedKB)KB freed)")
        }
    }

    /// Remove orphaned tool_result blocks from conversation history.
    /// A tool_result is orphaned if its tool_use_id doesn't match any tool_use
    /// block in a preceding assistant message. The Claude API rejects these.
    private func removeOrphanedToolResults() {
        // Collect all tool_use IDs from assistant messages
        var validToolUseIDs = Set<String>()
        for message in conversationHistory {
            guard let role = message["role"] as? String, role == "assistant" else { continue }
            guard let content = message["content"] as? [[String: Any]] else { continue }
            for block in content {
                if let type = block["type"] as? String, type == "tool_use",
                   let id = block["id"] as? String {
                    validToolUseIDs.insert(id)
                }
            }
        }

        // Find and remove messages that contain only orphaned tool_results
        var indicesToRemove: [Int] = []
        for (i, message) in conversationHistory.enumerated() {
            guard let role = message["role"] as? String, role == "user" else { continue }
            guard let content = message["content"] as? [[String: Any]] else { continue }

            // Check if ALL content blocks are orphaned tool_results
            let hasToolResults = content.contains { ($0["type"] as? String) == "tool_result" }
            guard hasToolResults else { continue }

            let allOrphaned = content.allSatisfy { block in
                guard let type = block["type"] as? String, type == "tool_result" else {
                    return false  // Non-tool_result blocks are fine
                }
                let toolUseId = block["tool_use_id"] as? String ?? ""
                return !validToolUseIDs.contains(toolUseId)
            }

            if allOrphaned {
                indicesToRemove.append(i)
            } else {
                // Filter out just the orphaned blocks, keep valid ones
                let filtered = content.filter { block in
                    guard let type = block["type"] as? String, type == "tool_result" else { return true }
                    let toolUseId = block["tool_use_id"] as? String ?? ""
                    return validToolUseIDs.contains(toolUseId)
                }
                if filtered.count < content.count {
                    var modified = message
                    modified["content"] = filtered
                    conversationHistory[i] = modified
                }
            }
        }

        // Remove fully orphaned messages in reverse order
        for i in indicesToRemove.reversed() {
            conversationHistory.remove(at: i)
        }

        if !indicesToRemove.isEmpty {
            NSLog("CyclopOne [AgentLoop]: Removed %d orphaned tool_result messages", indicesToRemove.count)
        }
    }

    /// Check if a conversation message contains image content (base64 screenshot data).
    func messageContainsImage(_ message: [String: Any]) -> Bool {
        guard let content = message["content"] else { return false }

        // Handle array-style content blocks (user messages, tool results)
        if let contentArray = content as? [[String: Any]] {
            return contentArray.contains { block in
                if let type = block["type"] as? String, type == "image" {
                    return true
                }
                // Check nested tool_result content blocks
                if let innerContent = block["content"] as? [[String: Any]] {
                    return innerContent.contains { inner in
                        (inner["type"] as? String) == "image"
                    }
                }
                return false
            }
        }

        return false
    }

    /// Replace image content blocks in a message with placeholder text.
    /// Returns the modified message and the approximate number of bytes removed.
    func pruneImageFromMessage(_ message: [String: Any]) -> ([String: Any], Int) {
        var modified = message
        var bytesRemoved = 0

        guard let content = message["content"] as? [[String: Any]] else {
            return (modified, 0)
        }

        var newContent: [[String: Any]] = []

        for block in content {
            if let type = block["type"] as? String, type == "image" {
                // Estimate the size of the base64 data being removed
                if let source = block["source"] as? [String: Any],
                   let data = source["data"] as? String {
                    bytesRemoved += data.utf8.count
                }
                // Replace with placeholder text block
                newContent.append([
                    "type": "text",
                    "text": "[screenshot removed]"
                ])
            } else if let innerContent = block["content"] as? [[String: Any]] {
                // Handle tool_result content blocks with nested images
                var newInnerContent: [[String: Any]] = []
                for inner in innerContent {
                    if let type = inner["type"] as? String, type == "image" {
                        if let source = inner["source"] as? [String: Any],
                           let data = source["data"] as? String {
                            bytesRemoved += data.utf8.count
                        }
                        newInnerContent.append([
                            "type": "text",
                            "text": "[screenshot removed]"
                        ])
                    } else {
                        newInnerContent.append(inner)
                    }
                }
                var modifiedBlock = block
                modifiedBlock["content"] = newInnerContent
                newContent.append(modifiedBlock)
            } else {
                newContent.append(block)
            }
        }

        modified["content"] = newContent
        return (modified, bytesRemoved)
    }

    /// Sprint 19: Get the approximate payload size of the current conversation history in bytes.
    /// Useful for monitoring and debugging payload growth.
    func conversationPayloadSize() -> Int {
        guard let data = try? JSONSerialization.data(withJSONObject: conversationHistory) else {
            return 0
        }
        return data.count
    }

    /// Sprint 18: Set skill context to inject into the system prompt for this run.
    func setSkillContext(_ context: String) {
        self.skillContext = context
    }

    /// Set memory context to inject into the system prompt for this run.
    func setMemoryContext(_ context: String) {
        self.memoryContext = context
    }

    /// Sprint 16: Restore conversation history from a replayed run state.
    ///
    /// Called by `Orchestrator.resumeRun(runId:)` to set up the agent's
    /// conversation context before resuming from the last committed iteration.
    /// Builds a synthetic conversation from the original user command and
    /// any tool calls/results recorded in the journal.
    ///
    /// - Parameters:
    ///   - command: The original user command text.
    ///   - completionToken: The new completion token for the resumed run.
    ///   - toolEvents: Tool execution events from the journal replay.
    ///   - screenshot: A fresh screenshot taken after relaunch.
    func restoreForResume(
        command: String,
        completionToken: String,
        toolEvents: [(tool: String, result: String?)],
        screenshot: ScreenCapture?
    ) async {
        isCancelled = false
        conversationHistory.removeAll()
        self.completionToken = completionToken
        consecutiveAPIFailures = 0
        iterationCount = 0  // Reset so prepareRun's work isn't wasted
        latestScreenshot = screenshot

        // Build the initial user message with the fresh screenshot
        var enhancedMessage = command
        if let ss = screenshot {
            enhancedMessage += "\n\n[Resumed after crash. Screenshot: \(ss.width)x\(ss.height)px. Actual screen: \(ss.screenWidth)x\(ss.screenHeight) points. Provide coordinates in screenshot pixel space.]"
        } else {
            enhancedMessage += "\n\n[Resumed after crash. No screenshot available.]"
        }

        // Read UI tree for the target app, not Cyclop One
        let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)

        let userMsg = ClaudeAPIService.buildUserMessage(
            text: enhancedMessage,
            screenshot: screenshot,
            uiTreeSummary: uiTree
        )
        conversationHistory.append(userMsg)

        // Reconstruct tool call/result pairs from journal events
        // This gives Claude context about what was already done before the crash
        if !toolEvents.isEmpty {
            // Build a synthetic assistant message summarizing previous work
            var summaryParts: [String] = ["[Previous actions before interruption:]"]
            for (i, event) in toolEvents.enumerated() {
                let resultText = event.result ?? "completed"
                summaryParts.append("\(i + 1). \(event.tool): \(resultText)")
            }
            let summaryText = summaryParts.joined(separator: "\n")

            let assistantMsg: [String: Any] = [
                "role": "assistant",
                "content": [
                    ["type": "text", "text": summaryText]
                ]
            ]
            conversationHistory.append(assistantMsg)

            // Add a user message indicating resume
            let resumeMsg = ClaudeAPIService.buildUserMessage(
                text: "The task was interrupted. Please continue from where you left off. Take a fresh screenshot to assess the current state before proceeding.",
                screenshot: screenshot,
                uiTreeSummary: uiTree
            )
            conversationHistory.append(resumeMsg)
        }
    }

    func updateConfig(_ newConfig: AgentConfig) {
        self.config = newConfig
    }

    // MARK: - Coordinate Mapping

    private func mapToScreen(x: Double, y: Double) -> (x: Double, y: Double) {
        guard let ss = latestScreenshot else { return (x, y) }
        return ss.toScreenCoords(x: x, y: y)
    }

    /// Ensure the target application is still the frontmost app before each iteration.
    /// If another app stole focus (e.g. Chrome, Finder), re-activate the target app.
    /// This prevents the agent from interacting with the wrong app mid-task.
    private func ensureTargetAppFocused() async {
        guard let targetPID = self.targetAppPID else { return }

        let currentPID = ProcessInfo.processInfo.processIdentifier
        let frontPID = await MainActor.run {
            NSWorkspace.shared.frontmostApplication?.processIdentifier
        }

        // If Cyclop One itself is frontmost, or a different app stole focus, re-activate target
        if let front = frontPID, front != targetPID {
            let frontName = await MainActor.run {
                NSWorkspace.shared.frontmostApplication?.localizedName ?? "unknown"
            }
            let targetName = await MainActor.run {
                NSRunningApplication(processIdentifier: targetPID)?.localizedName ?? "unknown"
            }

            // Only log and re-focus if a non-Cyclop One app stole focus
            // (Cyclop One steals focus naturally during screenshot/panel operations)
            if front != currentPID {
                NSLog("CyclopOne [AgentLoop]: Focus stolen by '%@' (PID %d), re-activating target '%@' (PID %d)",
                      frontName, front, targetName, targetPID)
            }

            await activateTargetApp()
            // Brief settle time after re-activation
            try? await Task.sleep(nanoseconds: 150_000_000) // 150ms
        }
    }

    /// Update targetAppPID from the current frontmost application.
    /// Called after clicks and app launches with a delay to let activation settle.
    private func updateTargetPID() async {
        try? await Task.sleep(nanoseconds: 200_000_000) // 200ms for activation
        let newPID = await MainActor.run { () -> pid_t? in
            let currentPID = ProcessInfo.processInfo.processIdentifier
            if let front = NSWorkspace.shared.frontmostApplication,
               front.processIdentifier != currentPID {
                return front.processIdentifier
            }
            return nil
        }
        if let pid = newPID { targetAppPID = pid }
    }

    // MARK: - Tool Execution

    private func executeToolCall(
        name: String,
        input: [String: Any],
        onStateChange: @Sendable @escaping (AgentState) -> Void,
        onMessage: @Sendable @escaping (ChatMessage) -> Void,
        onConfirmationNeeded: @Sendable @escaping (String) async -> Bool
    ) async -> ToolResult {

        onStateChange(.executing(name))

        switch name {

        case "run_shell_command":
            guard let command = input["command"] as? String else {
                return ToolResult(result: "Error: missing 'command'", isError: true)
            }
            if config.confirmDestructiveActions && config.isDestructive(command) {
                onStateChange(.awaitingConfirmation(command))
                let approved = await onConfirmationNeeded("Run destructive command?\n\n\(command)")
                if !approved {
                    return ToolResult(result: "User denied.", isError: false)
                }
            }
            do {
                let result = try await executor.runShellCommand(command, timeout: config.shellTimeout)
                onMessage(ChatMessage(role: .toolResult, content: "$ \(command)\n\(result.summary)"))
                return ToolResult(result: result.summary, isError: !result.isSuccess)
            } catch {
                return ToolResult(result: "Error: \(error.localizedDescription)", isError: true)
            }

        case "run_applescript":
            guard let script = input["script"] as? String else {
                return ToolResult(result: "Error: missing 'script'", isError: true)
            }
            do {
                let result = try await executor.runAppleScript(script)

                // If the script activated an app, update our target
                if script.lowercased().contains("activate") {
                    await updateTargetPID()
                }

                return ToolResult(result: "AppleScript: \(result)", isError: false)
            } catch {
                return ToolResult(result: "Error: \(error.localizedDescription)", isError: true)
            }

        case "click", "right_click":
            guard let rawX = input["x"] as? Double, let rawY = input["y"] as? Double else {
                return ToolResult(result: "Error: missing x/y", isError: true)
            }
            let isDouble = input["double_click"] as? Bool ?? false
            let isRight = (name == "right_click")
            let (sx, sy) = mapToScreen(x: rawX, y: rawY)

            // Sprint 7: Read configurable timing from executor
            let timing = await executor.timing

            // CRITICAL: Activate target app and let clicks through panel
            await activateTargetApp()
            await letClicksThrough()

            // Move mouse first (some apps need this), then click
            await accessibility.moveMouse(x: sx, y: sy)
            try? await Task.sleep(nanoseconds: timing.clickDelayBefore)

            let clickResult: AccessibilityService.ActionResult
            if isRight {
                clickResult = await accessibility.rightClickAt(x: sx, y: sy)
            } else if isDouble {
                clickResult = await accessibility.doubleClickAt(x: sx, y: sy)
            } else {
                clickResult = await accessibility.clickAt(x: sx, y: sy)
            }

            // Wait for the target app to process the click
            try? await Task.sleep(nanoseconds: timing.clickDelayAfter)

            await stopClicksThrough()

            // Update target to whatever app is now frontmost
            await updateTargetPID()

            if !clickResult.success {
                return ToolResult(result: "Error: \(clickResult.error ?? "click failed")", isError: true)
            }

            let clickType = isRight ? "Right-clicked" : (isDouble ? "Double-clicked" : "Clicked")
            return ToolResult(result: "\(clickType) at screenshot(\(Int(rawX)),\(Int(rawY))) → screen(\(Int(sx)),\(Int(sy)))", isError: false)

        case "type_text":
            guard let text = input["text"] as? String else {
                return ToolResult(result: "Error: missing 'text'", isError: true)
            }

            // Sprint 7: Read configurable timing from executor
            let typeTiming = await executor.timing

            // CRITICAL: Activate target app so keystrokes go to it, not our panel
            await activateTargetApp()

            let typeResult = await accessibility.typeText(text)

            if !typeResult.success {
                return ToolResult(result: "Error: \(typeResult.error ?? "typing failed")", isError: true)
            }

            // Wait for typing to complete (configurable per-char delay)
            let typingTime = UInt64(text.count) * typeTiming.typingDelayPerChar
            try? await Task.sleep(nanoseconds: max(typingTime, typeTiming.typingMinSettle))
            return ToolResult(result: "Typed: \(text.prefix(100))\(text.count > 100 ? "…" : "")", isError: false)

        case "press_key":
            guard let keyName = input["key"] as? String else {
                return ToolResult(result: "Error: missing 'key'", isError: true)
            }
            guard let keyCode = ActionExecutor.keyCodes[keyName.lowercased()] else {
                return ToolResult(result: "Error: unknown key '\(keyName)'", isError: true)
            }
            let cmd = input["command"] as? Bool ?? false
            let shift = input["shift"] as? Bool ?? false
            let opt = input["option"] as? Bool ?? false
            let ctrl = input["control"] as? Bool ?? false

            // CRITICAL: Activate target app so key presses go to it
            await activateTargetApp()

            var flags = CGEventFlags()
            if cmd { flags.insert(.maskCommand) }
            if shift { flags.insert(.maskShift) }
            if opt { flags.insert(.maskAlternate) }
            if ctrl { flags.insert(.maskControl) }
            let keyResult = await accessibility.pressShortcut(keyCode: keyCode, modifiers: flags)

            if !keyResult.success {
                return ToolResult(result: "Error: \(keyResult.error ?? "key press failed")", isError: true)
            }

            // Sprint 7: Configurable key press delay
            let keyTiming = await executor.timing
            try? await Task.sleep(nanoseconds: keyTiming.keyPressDelay)

            var desc = keyName
            if cmd { desc = "⌘+" + desc }
            if shift { desc = "⇧+" + desc }
            if opt { desc = "⌥+" + desc }
            if ctrl { desc = "⌃+" + desc }
            return ToolResult(result: "Pressed: \(desc)", isError: false)

        case "take_screenshot":
            // Only screenshots need full hide (so panel doesn't appear in image)
            NSLog("CyclopOne [AgentLoop]: take_screenshot — hiding panel for capture (maxDim=%d, quality=%.2f)",
                  config.screenshotMaxDimension, config.screenshotJPEGQuality)
            await hideForScreenshot()

            do {
                let ss = try await capture.captureScreen(
                    maxDimension: config.screenshotMaxDimension,
                    quality: config.screenshotJPEGQuality
                )
                latestScreenshot = ss

                NSLog("CyclopOne [take_screenshot]: %dx%d px, %@, base64=%d chars, data=%d bytes",
                      ss.width, ss.height, ss.mediaType, ss.base64.count, ss.imageData.count)
                // Save diagnostic copy for debugging
                let ext = ss.mediaType == "image/png" ? "png" : "jpg"
                try? ss.imageData.write(to: URL(fileURLWithPath: "/tmp/cyclopone_last_sent.\(ext)"))
                NSLog("CyclopOne [take_screenshot]: Diagnostic saved to /tmp/cyclopone_last_sent.%@", ext)

                // Read UI tree for the TARGET app, not Cyclop One
                let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)

                await showAfterScreenshot()

                // CRITICAL: include the screenshot image so Claude can SEE the result
                return ToolResult(
                    result: "Screenshot (\(ss.width)x\(ss.height), \(ss.mediaType), screen \(ss.screenWidth)x\(ss.screenHeight)).\nUI:\n\(uiTree)",
                    isError: false,
                    screenshot: ss
                )
            } catch {
                await showAfterScreenshot()
                return ToolResult(result: "Screenshot failed: \(error.localizedDescription)", isError: true)
            }

        case "open_application":
            guard let appName = input["name"] as? String else {
                return ToolResult(result: "Error: missing 'name'", isError: true)
            }
            do {
                let result = try await executor.openApplication(appName)
                try? await Task.sleep(nanoseconds: 1_500_000_000) // 1.5s for app launch

                // Update target to the newly opened/activated app
                let newPID = await MainActor.run { () -> pid_t? in
                    let currentPID = ProcessInfo.processInfo.processIdentifier
                    // Try to find the app by name first
                    if let app = NSWorkspace.shared.runningApplications.first(where: {
                        $0.localizedName?.lowercased() == appName.lowercased() &&
                        $0.processIdentifier != currentPID
                    }) {
                        return app.processIdentifier
                    }
                    // Fallback: whatever is now frontmost
                    if let front = NSWorkspace.shared.frontmostApplication,
                       front.processIdentifier != currentPID {
                        return front.processIdentifier
                    }
                    return nil
                }
                if let pid = newPID { targetAppPID = pid }

                // Auto-capture screenshot after opening so Claude can see the result
                await hideForScreenshot()
                var postScreenshot: ScreenCapture? = nil
                if let ss = try? await capture.captureScreen(
                    maxDimension: config.screenshotMaxDimension,
                    quality: config.screenshotJPEGQuality
                ) {
                    latestScreenshot = ss
                    postScreenshot = ss
                    let ext = ss.mediaType == "image/png" ? "png" : "jpg"
                    try? ss.imageData.write(to: URL(fileURLWithPath: "/tmp/cyclopone_last_sent.\(ext)"))
                }
                await showAfterScreenshot()

                let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)
                let screenshotInfo = postScreenshot.map { "Screenshot: \($0.width)x\($0.height)px" } ?? "No screenshot"
                return ToolResult(
                    result: "Opened \(appName): \(result). \(screenshotInfo)\nUI:\n\(uiTree)",
                    isError: false,
                    screenshot: postScreenshot
                )
            } catch {
                return ToolResult(result: "Error: \(error.localizedDescription)", isError: true)
            }

        case "open_url":
            guard let urlString = input["url"] as? String else {
                return ToolResult(result: "Error: missing 'url'", isError: true)
            }
            guard let url = URL(string: urlString), url.scheme != nil else {
                return ToolResult(result: "Error: invalid URL '\(urlString)'. Must include protocol (https:// or http://).", isError: true)
            }
            let browserName = input["browser"] as? String

            do {
                // Open URL in specified browser or default
                let opened: Bool
                if let browser = browserName {
                    // Open in specific browser using shell command
                    _ = try await executor.runShellCommand("open -a \"\(browser)\" \"\(urlString)\"", timeout: 10)
                    opened = true
                } else {
                    // Open in default browser via NSWorkspace
                    opened = await MainActor.run {
                        NSWorkspace.shared.open(url)
                    }
                }

                guard opened else {
                    return ToolResult(result: "Error: failed to open URL '\(urlString)'", isError: true)
                }

                // Wait for the browser to activate and page to start loading
                try? await Task.sleep(nanoseconds: 2_500_000_000) // 2.5s for page load

                // Update target to the browser
                await updateTargetPID()

                // Auto-capture screenshot after page loads
                await hideForScreenshot()
                var postScreenshot: ScreenCapture? = nil
                if let ss = try? await capture.captureScreen(
                    maxDimension: config.screenshotMaxDimension,
                    quality: config.screenshotJPEGQuality
                ) {
                    latestScreenshot = ss
                    postScreenshot = ss
                    let ext = ss.mediaType == "image/png" ? "png" : "jpg"
                    try? ss.imageData.write(to: URL(fileURLWithPath: "/tmp/cyclopone_last_sent.\(ext)"))
                }
                await showAfterScreenshot()

                let uiTree = await accessibility.getUITreeSummary(targetPID: targetAppPID)
                let screenshotInfo = postScreenshot.map { "Screenshot: \($0.width)x\($0.height)px" } ?? "No screenshot"
                return ToolResult(
                    result: "Opened URL \(urlString) in \(browserName ?? "default browser"). \(screenshotInfo)\nUI:\n\(uiTree)",
                    isError: false,
                    screenshot: postScreenshot
                )
            } catch {
                return ToolResult(result: "Error opening URL: \(error.localizedDescription)", isError: true)
            }

        case "move_mouse":
            guard let rawX = input["x"] as? Double, let rawY = input["y"] as? Double else {
                return ToolResult(result: "Error: missing x/y", isError: true)
            }
            let (sx, sy) = mapToScreen(x: rawX, y: rawY)
            await activateTargetApp()
            await letClicksThrough()
            await accessibility.moveMouse(x: sx, y: sy)
            try? await Task.sleep(nanoseconds: 200_000_000)
            await stopClicksThrough()
            return ToolResult(result: "Moved to screen(\(Int(sx)),\(Int(sy)))", isError: false)

        case "drag":
            guard let fX = input["from_x"] as? Double, let fY = input["from_y"] as? Double,
                  let tX = input["to_x"] as? Double, let tY = input["to_y"] as? Double else {
                return ToolResult(result: "Error: missing coordinates", isError: true)
            }
            let (sx1, sy1) = mapToScreen(x: fX, y: fY)
            let (sx2, sy2) = mapToScreen(x: tX, y: tY)

            await activateTargetApp()
            await letClicksThrough()
            await accessibility.drag(fromX: sx1, fromY: sy1, toX: sx2, toY: sy2)
            try? await Task.sleep(nanoseconds: 300_000_000)
            await stopClicksThrough()
            return ToolResult(result: "Dragged (\(Int(sx1)),\(Int(sy1))) → (\(Int(sx2)),\(Int(sy2)))", isError: false)

        case "scroll":
            guard let rawX = input["x"] as? Double, let rawY = input["y"] as? Double else {
                return ToolResult(result: "Error: missing x/y", isError: true)
            }
            let deltaY = input["delta_y"] as? Int ?? -3
            let (sx, sy) = mapToScreen(x: rawX, y: rawY)

            await activateTargetApp()
            await letClicksThrough()
            await accessibility.scroll(x: sx, y: sy, deltaY: deltaY)
            try? await Task.sleep(nanoseconds: 200_000_000)
            await stopClicksThrough()
            return ToolResult(result: "Scrolled \(deltaY > 0 ? "up" : "down") \(abs(deltaY)) at (\(Int(sx)),\(Int(sy)))", isError: false)

        // ── Vault Management Tools ──

        case "vault_read":
            guard let path = input["path"] as? String else {
                return ToolResult(result: "Error: missing 'path'", isError: true)
            }
            let content = await MemoryService.shared.readNote(at: path)
            return ToolResult(result: content ?? "Note not found: \(path)", isError: content == nil)

        case "vault_write":
            guard let path = input["path"] as? String,
                  let content = input["content"] as? String else {
                return ToolResult(result: "Error: missing 'path' or 'content'", isError: true)
            }
            do {
                try await MemoryService.shared.writeNote(at: path, content: content)
                return ToolResult(result: "Wrote note: \(path)", isError: false)
            } catch {
                return ToolResult(result: "Error writing note: \(error.localizedDescription)", isError: true)
            }

        case "vault_append":
            guard let path = input["path"] as? String,
                  let content = input["content"] as? String else {
                return ToolResult(result: "Error: missing 'path' or 'content'", isError: true)
            }
            do {
                try await MemoryService.shared.appendToNote(at: path, text: content)
                return ToolResult(result: "Appended to note: \(path)", isError: false)
            } catch {
                return ToolResult(result: "Error appending to note: \(error.localizedDescription)", isError: true)
            }

        case "vault_search":
            guard let query = input["query"] as? String else {
                return ToolResult(result: "Error: missing 'query'", isError: true)
            }
            let folder = input["directory"] as? String
            let limit = input["limit"] as? Int ?? 10
            let results = await MemoryService.shared.searchNotes(query: query, folder: folder, limit: limit)
            if results.isEmpty {
                return ToolResult(result: "No notes found matching: \(query)", isError: false)
            }
            let formatted = results.map { "**\($0.path)**: \($0.snippet)" }.joined(separator: "\n\n")
            return ToolResult(result: formatted, isError: false)

        case "vault_list":
            let directory = input["directory"] as? String ?? ""
            let items = await MemoryService.shared.listNotes(in: directory)
            if items.isEmpty {
                return ToolResult(result: "Directory is empty or does not exist: \(directory)", isError: false)
            }
            return ToolResult(result: items.joined(separator: "\n"), isError: false)

        // ── Task Management Tools ──

        case "task_create":
            guard let title = input["title"] as? String else {
                return ToolResult(result: "Error: missing 'title'", isError: true)
            }
            let details = input["details"] as? String ?? ""
            let priority = input["priority"] as? String ?? "medium"
            let project = input["project"] as? String
            do {
                let path = try await MemoryService.shared.createTask(
                    title: title, description: details,
                    priority: priority, project: project
                )
                return ToolResult(result: "Created task: \(title) at \(path)", isError: false)
            } catch {
                return ToolResult(result: "Error creating task: \(error.localizedDescription)", isError: true)
            }

        case "task_update":
            guard let title = input["title"] as? String,
                  let status = input["status"] as? String else {
                return ToolResult(result: "Error: missing 'title' or 'status'", isError: true)
            }
            let notes = input["notes"] as? String
            await MemoryService.shared.updateTaskByTitle(title: title, status: status, notes: notes)
            return ToolResult(result: "Updated task '\(title)' to status: \(status)", isError: false)

        case "task_list":
            let status = input["status"] as? String
            let project = input["project"] as? String
            let list = await MemoryService.shared.listTasks(status: status, project: project)
            return ToolResult(result: list, isError: false)

        // ── Memory Shortcut Tools ──

        case "remember":
            guard let fact = input["fact"] as? String else {
                return ToolResult(result: "Error: missing 'fact'", isError: true)
            }
            let category = input["category"] as? String ?? "fact"
            await MemoryService.shared.remember(fact: fact, category: category)
            return ToolResult(result: "Remembered [\(category)]: \(fact)", isError: false)

        case "recall":
            guard let topic = input["topic"] as? String else {
                return ToolResult(result: "Error: missing 'topic'", isError: true)
            }
            let memories = await MemoryService.shared.recall(topic: topic)
            return ToolResult(result: memories, isError: false)

        // ── OpenClaw Communication Tools ──

        case "openclaw_send":
            guard let message = input["message"] as? String else {
                return ToolResult(result: "Error: missing 'message'", isError: true)
            }
            let channel = input["channel"] as? String ?? "telegram"
            let target = input["target"] as? String ?? ""
            do {
                let result = try await OpenClawBridge.shared.sendMessage(
                    channel: channel, target: target, message: message
                )
                return ToolResult(result: "Message sent via \(channel): \(result)", isError: false)
            } catch {
                return ToolResult(result: "Error sending message: \(error.localizedDescription)", isError: true)
            }

        case "openclaw_check":
            let channel = input["channel"] as? String ?? "telegram"
            let target = input["target"] as? String ?? ""
            let limit = input["limit"] as? Int ?? 10
            do {
                let messages = try await OpenClawBridge.shared.readMessages(
                    channel: channel, target: target, limit: limit
                )
                if messages.isEmpty {
                    return ToolResult(result: "No new messages.", isError: false)
                }
                let formatted = messages.map { msg in
                    let sender = msg.sender ?? "unknown"
                    let time = msg.timestamp.map { ISO8601DateFormatter().string(from: $0) } ?? ""
                    return "[\(time)] \(sender): \(msg.text)"
                }.joined(separator: "\n")
                return ToolResult(result: formatted, isError: false)
            } catch {
                return ToolResult(result: "Error reading messages: \(error.localizedDescription)", isError: true)
            }

        default:
            // Check if it's a plugin tool
            if await PluginLoader.shared.isPluginTool(name) {
                do {
                    let pluginResult = try await PluginLoader.shared.executeTool(
                        name: name, input: input
                    )
                    return ToolResult(
                        result: pluginResult.result,
                        isError: pluginResult.isError
                    )
                } catch {
                    return ToolResult(
                        result: "Plugin error: \(error.localizedDescription)",
                        isError: true
                    )
                }
            }
            return ToolResult(result: "Unknown tool: \(name)", isError: true)
        }
    }
}

// MARK: - Tool Result

struct ToolResult {
    let result: String
    let isError: Bool
    var screenshot: ScreenCapture? = nil
}

// MARK: - Iteration Result

/// Result of a single agent iteration (one Claude API call + tool execution).
/// Used by the Orchestrator to decide whether to continue, verify, or stop.
struct IterationResult {
    /// Text content from Claude's response (may contain completion token).
    let textContent: String

    /// Whether Claude returned tool calls (wants to continue working).
    let hasMoreWork: Bool

    /// The most recent screenshot from this iteration (for stuck detection + journal).
    let screenshot: ScreenCapture?

    /// API token usage for this iteration.
    let inputTokens: Int
    let outputTokens: Int

    /// Whether the iteration was interrupted by cancellation.
    let cancelled: Bool

    /// Whether any tool calls in this iteration produce visual changes on screen.
    /// False when only non-visual tools (memory, vault, task) were called.
    let hasVisualToolCalls: Bool
}
